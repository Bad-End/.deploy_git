<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【模板】01背包</title>
    <url>/2018/01/21/01bags/</url>
    <content><![CDATA[<p>   f[i]表示背包已用i容量时能得到的最大价值，value[i]表示第i个物体的价值，size[i]表示第i个物品所要占据的背包容量（或者说是重量、时间之类的）。那么我们的决策就是要不要把当前处理的物品放入背包中。我们可以得到方程$f[i]=\max(f[i],f[i-size[i]]+value[i])$。题目链接<a href="https://www.luogu.org/problemnew/show/P1048">采药</a><br>   <a id="more"></a>  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> value[MAXN], size[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;size[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= size[i]; j--) &#123;</span><br><span class="line">            f[j] = max(f[j], f[j - size[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模板</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【AHOI2017/HNOI2017】礼物</title>
    <url>/2018/09/15/AHOI2017gift/</url>
    <content><![CDATA[<h3 id="题目链接-【AHOI2017-HNOI2017】礼物"><a href="#题目链接-【AHOI2017-HNOI2017】礼物" class="headerlink" title="题目链接 【AHOI2017/HNOI2017】礼物"></a>题目链接 <a href="https://www.luogu.org/problemnew/show/P3723">【AHOI2017/HNOI2017】礼物</a></h3><a id="more"></a>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>其实修改亮度可以看做对其中一串手环整体加或者整体减去 $c$ ，所以只要在括号里加上 $c$ 就可以了。原来的式子就变长了这样：</p>
<p>$$\sum_{i=1}^n(x_i-y_i +c)^2$$ </p>
<p>我们继续拆一下式子</p>
<p>$$\sum_{i=1}^n(x_i^2+y_i^2+c^2+2<em>c</em>x_i-2<em>c</em>y_i-2x_iy_i)$$ </p>
<p>$$\sum_{i=1}^n(x_i^2+y_i^2)+nc^2+2*c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i$$ </p>
<p>然后你会惊奇地发现，枚举了 $c$ 之后，除了最后一项之外都是常量。同时又是以最小化这个式子的值为目标的，所以只需要最大化$\sum_{i=1}^nx_iy_i$就可以了。</p>
<p>现在把 $y_i$ 翻转，那么原来的式子就变成了这样</p>
<p>$$\sum_{i=1}^{n}x_iy_{n-i+1}$$ </p>
<p>那你再把下标往左整体平移一下，</p>
<p>$$\sum_{i=0}^{n-1}x_iy_{n-i}$$ </p>
<p>这不是卷积吗？那我们只需要做一遍 $FFT$ 再错位处理一下，取一个最大值就可以了。</p>
<p>思考下 $FFT$ 的本质，画一张图，就能理解如何错位了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">std</span>::<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span><span class="comment">//自定义负数类</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * a.x - y * a.y, x * a.y + y * a.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum1, sum2;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>, e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAXN], v[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex *p, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">std</span>::swap(p[i], p[r[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; len; l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">root</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">cos</span>(PI / l), type * <span class="built_in">std</span>::<span class="built_in">sin</span>(PI / l))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += (l &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">t</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++, t = t * root) &#123;</span><br><span class="line">                Complex x = p[i + j], y = t * p[i + l + j];</span><br><span class="line">                p[i + j] = x + y;</span><br><span class="line">                p[i + l + j] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); n--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;b[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum1 += a[i].x * a[i].x + b[i].x * b[i].x;</span><br><span class="line">        sum2 += a[i].x - b[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n2 = n + n;</span><br><span class="line">    <span class="built_in">std</span>::reverse(b, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n2) len &lt;&lt;= <span class="number">1</span>, e++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (e - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    fft(a, <span class="number">1</span>), fft(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        a[i] = a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fft(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n2; i++) &#123;</span><br><span class="line">        v[i] = (<span class="keyword">int</span>)(a[i].x / len + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> val = v[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//错位处理</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; v[i] + v[i + n + <span class="number">1</span>]) &#123;</span><br><span class="line">            val = v[i] + v[i + n + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = -m; i &lt;= m; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, sum2 * <span class="number">2</span> * i + (n + <span class="number">1</span>) * i * i - val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + sum1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2018/08/05/EXSegmentTree/</url>
    <content><![CDATA[<p>你需要写一种数据结构（可不参考题目标题），支持以下操作：</p>
<a id="more"></a>

<p>$\text{sum} ; l ; r$求区间 $[l,r]$ 的和。</p>
<p>$\text{max} ; l ; r$求区间 $[l,r]$ 的最大值。</p>
<p>$min ; l ; r ​$求区间$[l,r] ​$的最小值。</p>
<p>$add ; l ; r ; v$将区间 $[l,r]$ 内的所有数都加上 $v$ 。</p>
<p>$xor ; x ; v$将第 $x$ 个数按位异或 $v$ 。</p>
<p>$average ;l ; r$求区间 $[l,r]$ 内所有数的平均值（保留两位小数）。</p>
<p>$reverse ; l ; r$将区间 $[l,r]$ 内的所有数都变为原来的相反数。</p>
<p>$set l ; r ; v$将区间 $[l,r]$ 内的所有数都变成 $v$ 。</p>
<p>$square ; l ; r$求区间 $[l,r]$ 内所有数的平方和。</p>
<p>注意：对于操作 1 和 9，输出要对 $1000000007$ 取模。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll HA = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line">    ll sum, max, min, sqr, add, cov, mul;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> fsum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> newNode(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode(l, r, build(l, mid), build(mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        sum = (lc-&gt;sum + rc-&gt;sum) % HA;</span><br><span class="line">        max = <span class="built_in">std</span>::max(lc-&gt;max, rc-&gt;max);</span><br><span class="line">        min = <span class="built_in">std</span>::min(lc-&gt;min, rc-&gt;min);</span><br><span class="line">        sqr = (lc-&gt;sqr + rc-&gt;sqr) % HA;</span><br><span class="line">        fsum = lc-&gt;fsum + rc-&gt;fsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cov != LLONG_MIN) &#123;</span><br><span class="line">            lc-&gt;cover(cov), rc-&gt;cover(cov);</span><br><span class="line">            cov = LLONG_MIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (add  != <span class="number">0</span> || mul == <span class="number">-1</span>)&#123;</span><br><span class="line">            lc-&gt;multiply(mul), rc-&gt;multiply(mul);</span><br><span class="line">            mul = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            lc-&gt;plus(add), rc-&gt;plus(add);</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(ll c)</span> </span>&#123;</span><br><span class="line">        sum = ((c % HA) * (r - l + <span class="number">1</span>) % HA) % HA;</span><br><span class="line">        fsum = c * (r - l + <span class="number">1</span>);</span><br><span class="line">        max = c;</span><br><span class="line">        min = c;</span><br><span class="line">        sqr = ((c % HA) * ((c % HA) * (r - l + <span class="number">1</span>) % HA) % HA) % HA;</span><br><span class="line"></span><br><span class="line">        cov = c, add = <span class="number">0</span>, mul = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(ll m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        sum = -sum;</span><br><span class="line">        max = -max, min = -min, <span class="built_in">std</span>::swap(max, min);</span><br><span class="line">        fsum = -fsum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cov != LLONG_MIN) &#123;</span><br><span class="line">            cov *= <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add *= <span class="number">-1</span>;</span><br><span class="line">            mul *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">        max += a, min += a;</span><br><span class="line">        fsum += a * (r - l + <span class="number">1</span>);</span><br><span class="line">        a = (a % HA);</span><br><span class="line">        sqr = (sqr + <span class="number">2</span> * (a * sum) % HA + ((r - l + <span class="number">1</span>) * (a * a) % HA) % HA) % HA;</span><br><span class="line">        sum = (sum + ((r - l + <span class="number">1</span>) * (a % HA)) % HA) % HA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cov != LLONG_MIN) &#123;</span><br><span class="line">            cov += a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveAdd</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> plus(delta);</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;solveAdd(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;solveAdd(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;solveAdd(left, mid, delta), rc-&gt;solveAdd(mid + <span class="number">1</span>, right, delta);</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveMul</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right)  <span class="keyword">return</span> multiply(<span class="number">-1</span>);</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;solveMul(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;solveMul(left, right);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;solveMul(left, mid), rc-&gt;solveMul(mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveCov</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> cover(delta);</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;solveCov(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;solveCov(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;solveCov(left, mid, delta), rc-&gt;solveCov(mid + <span class="number">1</span>, right, delta);</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> sum % HA;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;querySum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;querySum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (lc-&gt;querySum(left, mid) + rc-&gt;querySum(mid + <span class="number">1</span>, right)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> max;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;queryMax(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;queryMax(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">std</span>::max(lc-&gt;queryMax(left, mid), rc-&gt;queryMax(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> min;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;queryMin(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;queryMin(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">std</span>::min(lc-&gt;queryMin(left, mid), rc-&gt;queryMin(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">querySqr</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> sqr % HA;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;querySqr(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;querySqr(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (lc-&gt;querySqr(left, mid) + rc-&gt;querySqr(mid + <span class="number">1</span>, right)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">queryFsum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> fsum;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;queryFsum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;queryFsum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lc-&gt;queryFsum(left, mid) + rc-&gt;queryFsum(mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *tree, poor[MAXN &lt;&lt; <span class="number">2</span>], *tail = poor;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;l = l, ret-&gt;r = r, ret-&gt;mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    ret-&gt;lc = lc, ret-&gt;rc = rc;</span><br><span class="line">    ret-&gt;sum = <span class="number">0</span>, ret-&gt;max = LLONG_MIN, ret-&gt;min = LLONG_MAX;</span><br><span class="line">    ret-&gt;sqr = <span class="number">0</span>, ret-&gt;add = <span class="number">0</span>, ret-&gt;cov = LLONG_MIN, ret-&gt;mul = <span class="number">1</span>;</span><br><span class="line">    ret-&gt;fsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    tree = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    ll value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;value);</span><br><span class="line">        tree-&gt;solveCov(i, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">    ll f, l, r, d;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;f, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (tree-&gt;querySum(l, r) + HA) % HA);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tree-&gt;queryMax(l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tree-&gt;queryMin(l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            tree-&gt;solveAdd(l, r, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">5</span>) &#123;</span><br><span class="line">            ll arch = tree-&gt;queryMax(l, l);</span><br><span class="line">            arch = arch ^ r;</span><br><span class="line">            tree-&gt;solveCov(l, l, arch);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, (<span class="keyword">double</span>)(tree-&gt;queryFsum(l, r)) / (<span class="keyword">double</span>)(r - l + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">7</span>) &#123;</span><br><span class="line">            tree-&gt;solveMul(l, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            tree-&gt;solveCov(l, r, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (tree-&gt;querySqr(l, r) + HA) % HA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>A+B Problem</title>
    <url>/2018/01/14/L1001/</url>
    <content><![CDATA[<p>By<a href="http://blog.aor.sd.cn/2017/12/03/SegmentTree.html">吴雨航</a></p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left,right,sum,tag;</span><br><span class="line">    SegmentTree *lc,*rc;</span><br><span class="line">    SegmentTree(<span class="keyword">int</span> left,<span class="keyword">int</span> right,SegmentTree *lc,SegmentTree *rc) : left(left), right(right), lc(lc), rc(rc), sum(<span class="number">0</span>), tag(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> l == r ? <span class="keyword">new</span> SegmentTree(l,r,<span class="literal">NULL</span>,<span class="literal">NULL</span>) : <span class="keyword">new</span> SegmentTree(l,r,build(l,mid),build(mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">        sum += (right - left + <span class="number">1</span>) * delta;</span><br><span class="line">        tag += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag)&#123;</span><br><span class="line">            lc-&gt;cover(tag);</span><br><span class="line">            rc-&gt;cover(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; right || r &lt; left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= left &amp;&amp; r &gt;= right) cover(delta);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            lc-&gt;modify(l,r,delta);</span><br><span class="line">            rc-&gt;modify(l,r,delta);</span><br><span class="line">            sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; right || r &lt; left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= left &amp;&amp; r &gt;= right) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;query(l,r) + rc-&gt;query(l,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    SegmentTree *segt;</span><br><span class="line">    segt = SegmentTree::build(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        segt-&gt;modify(i,i,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; segt-&gt;query(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【LYOI】20181101 Solution</title>
    <url>/2018/11/01/November-First/</url>
    <content><![CDATA[<p>Solution for LYOI contest 【2018.11.1】</p>
<a id="more"></a>

<h2 id="王太阳做糖"><a href="#王太阳做糖" class="headerlink" title="王太阳做糖"></a>王太阳做糖</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们把字母对记为$(l, r)$。</p>
<p>我们对于任意一个字母$(l_0,r_0)$，和它交叉的字母对$(l,r)$一定符合以下两点：</p>
<p>$$l_0 &lt; l &lt; r_0$$</p>
<p>$$r &gt; r_0$$</p>
<p>就是说左端点和$(l_0,r_0)$重合，这样计算不会算重。</p>
<p>因为是相同的字母两两配对，所以对相同字母组成的线段，一定不相交，更不存在包含的情况。</p>
<p>所以对于每个字母，与$(l_0,r_0)$这样相交的字母对最多只有一个。</p>
<p>记$pre_{i,c}​$表示前i个字母中，字母 $\text{c}​$ 组成的字母对的左端点 $\text{l}​$ 最后出现的位置，$next_i​$表示第 $\text{i}​$ 个字母，若其为左端点，与其配对的右端点的位置。</p>
<p>这样对于每个字母对就可以求出与它相交的字母对数了。</p>
<p>时间复杂度$O(n)$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN][base], next[MAXN], pos[MAXN][base], cnt[base];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;cross.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;cross.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pos[++cnt[num]][num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">            pre[i][j] = pre[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[num] &amp; <span class="number">1</span>) pre[i][num] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; base; c++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= cnt[c]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">2</span> * i - <span class="number">1</span>, r = <span class="number">2</span> * i;</span><br><span class="line">            next[pos[l][c]] = pos[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; base; c++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">2</span> * i &lt;= cnt[c]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = pos[<span class="number">2</span> * i - <span class="number">1</span>][c], r = pos[<span class="number">2</span> * i][c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[r][j] &gt; l) &#123;</span><br><span class="line">                    ans += next[pre[r][j]] &gt; r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="王太阳要糖"><a href="#王太阳要糖" class="headerlink" title="王太阳要糖"></a>王太阳要糖</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题面很长，干货很少。</p>
<p>读完题不难发现，只需要维护这张图的连通性就可以了，这个可以使用并查集实现。</p>
<p>难点在于如何查询历史连通性（<del>当然是可持久化并查集了</del>）。</p>
<p>实际上不需要可持久化并查集。</p>
<p>并查集如果不路径压缩的话，实际上树，树高在随机情况为$\log_2 n$,每次合并操作实际上是合并两颗树，查询操作是查询根节点。那么我们想要查询了历史版本的话，只需要记录每条边是什么时候加入的，查询操作只能顺着合法的边往上跳。</p>
<p>但是经过构造的数据可以卡掉这种未经优化的并查集，树的形态可能会极不优美。</p>
<p>所以我们使用按秩合并，把树高小的合并到树高大的树上，这样每次合并操作最多会使得树高$+1$。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN], h[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">int</span> t, ans;</span><br><span class="line"><span class="keyword">char</span> opr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (f[x] &gt;= <span class="number">0</span> &amp;&amp; g[x] &lt;= t) x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    x = get(x, t), y = get(y, t);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (h[x] &gt; h[y]) <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">    f[x] = y, g[x] = t;</span><br><span class="line">    h[y] += (h[x] == h[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	freopen(<span class="string">&quot;history.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;history.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> t, x, y, z, v;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) h[i] = <span class="number">1</span>, f[i] = <span class="number">-1</span>;</span><br><span class="line">        t = c = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opr);</span><br><span class="line">            <span class="keyword">if</span> (*opr == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), c = c * ans + v, ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                x = (c * ans + x) % n;</span><br><span class="line">                y = (c * ans + y) % n;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (*opr == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    merge(x, y, ++t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;z);</span><br><span class="line">                    z = (c * ans + z) % n;</span><br><span class="line">                    ans = ((get(x, t) == get(y, t)) == (get(x, t - z) == get(y, t - z)));   </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ans ? <span class="string">&#x27;N&#x27;</span> : <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="王太阳爬树"><a href="#王太阳爬树" class="headerlink" title="王太阳爬树"></a>王太阳爬树</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>入门级树形DP。</p>
<p>设$f_i$表示对于标号为 $\text{i}$ 的节点，使其所有叶子节点与 $\text{i}$ 不连通的最小代价。</p>
<p>对于一个节点 $\text{u}$ ，我们枚举它的所有儿子 $\text{v}$，$\text{(u,v)}$的边权为 $\text{w}$。</p>
<p>$$f_u=f_u+\min {w,f_v}$$</p>
<p>代码也超级短，注意初始化叶子节点就好了。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, w, next;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt;</span><br><span class="line"></span><br><span class="line">ll f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[++cnt] = &#123;v, w, head[u]&#125;; head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        f[u] += <span class="built_in">std</span>::min(<span class="number">1l</span>l * edge[e].w, f[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) f[u] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w), add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[s]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>并查集</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】SPFA算法</title>
    <url>/2018/01/14/SPFA/</url>
    <content><![CDATA[<p>SPFA算法是Bellman-Ford（蛤？你说你不知道Bellman-Ford算法？）算法的队列实现方法，采取动态逼近的方式来求得单源最短路，时间复杂度为O（ek）e为边数，k是所有点进队的平均次数。适用于不存在负权回路的稀疏图。</p>
<a id="more"></a>
<p>下面给出指针写法，题目参考洛谷<a href="https://www.luogu.org/problemnew/show/3371">【模板】单源最短路径</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span><span class="comment">//定义结构体，Node为节点，Edge为边</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Edge *firstEdge;</span><br><span class="line">    <span class="keyword">int</span> dist;<span class="comment">//距起点的最小距离</span></span><br><span class="line">    <span class="keyword">bool</span> inQueue;<span class="comment">//判断是否再队列中</span></span><br><span class="line">&#125;node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    Node *from,*to;<span class="comment">//起点与终点</span></span><br><span class="line">    <span class="keyword">int</span> w;<span class="comment">//边权</span></span><br><span class="line">    Edge *next;</span><br><span class="line">    Edge(Node *from,Node *to,<span class="keyword">int</span> w) : from(from),to(to),w(w),next(from -&gt; firstEdge) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s],&amp;node[t],w);<span class="comment">//把边加入结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        node[i].dist = INT_MAX;</span><br><span class="line">        node[i].inQueue = <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="comment">//初始化，使所有点到起点的距离为无穷大，所有点都不在队列中</span></span><br><span class="line">    <span class="built_in">queue</span> &lt;Node *&gt; q;<span class="comment">//通过队列来进行松弛操作，动态逼近，这里采用STL写法</span></span><br><span class="line">    q.push(&amp;node[s]);</span><br><span class="line">    node[s].inQueue = <span class="literal">true</span>;</span><br><span class="line">    node[s].dist = <span class="number">0</span>;<span class="comment">//把起点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;<span class="comment">//队列不能为空</span></span><br><span class="line">        Node *u = q.front();<span class="comment">//每次从队首处理</span></span><br><span class="line">        q.pop();</span><br><span class="line">        u -&gt; inQueue = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge *e = u -&gt; firstEdge;e;e = e -&gt; next)&#123;<span class="comment">//枚举所有与u相连的边，查找能够更新dist的点</span></span><br><span class="line">            Node *v = e -&gt; to;</span><br><span class="line">            <span class="keyword">if</span>(v -&gt; dist &gt; e -&gt; w + u -&gt; dist)&#123;</span><br><span class="line">                v -&gt; dist = e -&gt; w + u -&gt; dist;</span><br><span class="line">                <span class="keyword">if</span>(! v-&gt; inQueue)&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    v -&gt; inQueue = <span class="literal">true</span>;<span class="comment">//如果不在队列中，就使其入队</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">int</span> u,v,l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;           <span class="comment">//读入</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;u,&amp;v,&amp;l);</span><br><span class="line">        add(u,v,l);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[i].dist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】线段树</title>
    <url>/2018/05/06/SegmentTree/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线段树是一种二叉搜索树，用来维护区间内的符合区间加法的值，支持高效的查询与修改操作。每一次操作的时间复杂度是 $O(log_2N)$ </p>
<a id="more"></a>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>线段树把区间[l,r]分成了[l,mid]与[mid+1,r]两部分。线段树把区间[1,n]一直递归地划分下去，直到区间内只有一个点为止，也就是到达了叶子结点。线段树的每个节点都存储了这个序列的一段区间，从根节点开始按照刚才所叙述的划分方法一直划分到叶子结点。每个结点都存储着这个区间的信息，以优化查询的时间。</p>
<h2 id="Lazytag"><a href="#Lazytag" class="headerlink" title="Lazytag"></a>Lazytag</h2><p>按照这种方式存储序列可以很快地查询这段区间内维护的值，因为是二叉树，所以时间复杂度为 $log_2N$ 。但是如果进行区间修改的话要修改的值反而更多了，该如何解决呢？那就是Lazytag。</p>
<p>要进行区间修改时，只修改这个区间的节点代表的值，不修改它孩子节点的值，而是用一个标记记录下来，表示这个区间要整体修改一个值。当在有标记的节点进行查询与修改操作时，在把这个标记下推(也就是代码中的push_down函数)。这样就能避免不必要的区间修改。</p>
<h1 id="混合运算"><a href="#混合运算" class="headerlink" title="混合运算"></a>混合运算</h1><p>当一颗线段树同时要支持区间加法与区间乘法时，需要特别注意运算顺序。也就是在下推标记的时候，先进行乘法标记的下推，再进行加法标记的下推。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://www.luogu.org/problemnew/show/P3373">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">New</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span> , SegmentTree *, SegmentTree *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll sum, add, mul;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left == right ? New(left, right, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">            : New(left, right, build(left, mid), build(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum = (lc-&gt;sum + rc-&gt;sum) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mulCover</span><span class="params">(ll d)</span> </span>&#123;</span><br><span class="line">        sum = (sum * d) % p;</span><br><span class="line">        mul = (mul * d) % p;</span><br><span class="line">        add = (add * d) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCover</span><span class="params">(ll d)</span> </span>&#123;</span><br><span class="line">        add = (add + d) % p;</span><br><span class="line">        sum = (sum + d * (r - l + <span class="number">1</span>)) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lc-&gt;mulCover(mul); lc-&gt;addCover(add);</span><br><span class="line">        rc-&gt;mulCover(mul); rc-&gt;addCover(add);</span><br><span class="line">        mul = <span class="number">1</span>;</span><br><span class="line">        add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mulUpdate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; r || right &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= l &amp;&amp; right &gt;= r) mulCover(d);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            push_down();</span><br><span class="line">            lc-&gt;mulUpdate(left, right, d);</span><br><span class="line">            rc-&gt;mulUpdate(left, right, d);</span><br><span class="line">            push_up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUpdate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; r || right &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= l &amp;&amp; right &gt;= r) addCover(d);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            push_down();</span><br><span class="line">            lc-&gt;addUpdate(left, right, d);</span><br><span class="line">            rc-&gt;addUpdate(left, right, d);</span><br><span class="line">            push_up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; r || right &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= l &amp;&amp; right &gt;= r) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            push_down();</span><br><span class="line">            <span class="keyword">return</span> (lc-&gt;query(left, right) + rc-&gt;query(left, right)) % p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; *tree, poor[MAXN * <span class="number">4</span>], *tail = poor;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">New</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;sum = ret-&gt;add = <span class="number">0</span>;</span><br><span class="line">    ret-&gt;mul = <span class="number">1</span>;</span><br><span class="line">    ret-&gt;l = l; ret-&gt;r = r;</span><br><span class="line">    ret-&gt;lc = lc; ret-&gt;rc = rc;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    tree = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;now);</span><br><span class="line">        tree-&gt;addUpdate(i, i, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag, x, y, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;flag, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            tree-&gt;mulUpdate(x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            tree-&gt;addUpdate(x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tree-&gt;query(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模板</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Treap学习笔记</title>
    <url>/2018/07/21/Treap/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> $\text{Treap}$ 是一种附加了堆性质的二叉搜索树( $\text{ Binary Search Tree }$ ，简称 $\text{BST}$ )，但是不同于堆的是， $\text{Treap}$ 不必是完全二叉树。 $\text{Treap}$ 也正是由此得名($\text{Treap = Tree + Heap}$)，其原理是利用随机性来使树平衡，是一种实现简单的平衡树，能够完成 $\text{BST}$ 的各项基本操作，各基本操作的期望时间复杂度为 $O(\log_2n)$ 。  </p>
<a id="more"></a>  

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于一颗 $\text{BST}$ ，如果其结点的插入顺序是无序的，那么它有极大的概率是平衡的，即使存在一些极端情况，但是极少发生。那么便可以利用随机性来使 $\text{BST}$ 平衡。对于每个结点，对其附加一个随机的数值，以这些随机的数值决定其优先级，使其符合堆的性质（大根堆或者小根堆）。  </p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>我们可以用旋转的方法来同时维护堆和二叉搜索树的性质。<br>二叉搜索树的节点的键值要大于等于其左儿子的键值，小于等于其右儿子的键值，其中序遍历是有序的。那么其形态显然不唯一，可以通过旋转改变其形态，同时能保持其性质和中序遍历不变。<br>旋转操作也可以改变结点与其子树的位置关系，那么也可以用来维护堆的性质。<br>对于 $Treap$ 旋转操作分为两种，左旋与右旋。对于 $v$ 来说，左旋是指将 $v$ 的右子树绕着 $v$ 点向左旋转，代替 $v$ 点的位置。那么这样会产生新的问题。如果 $v$ 的右子树有左子树，那么就会产生冲突。其实只需要让 $v$ 的右子树的左子树成为 $v$ 的右子树即可。<br>右旋与左旋的方向相反。<br>下面给出例子来便于理解，从左到右为右旋，反之为左旋。（图片取自<a href="http://blog.aor.sd.cn/2018/05/02/%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">Rain Air’s Blog</a>）<br><img src="http://p3o3ovvyn.bkt.clouddn.com/rotate.png" alt="旋转">  </p>
<p>旋转的代码如下  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//左旋</span></span><br><span class="line">    Node *tmp = v-&gt;right;</span><br><span class="line">    v-&gt;right = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();</span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//右旋</span></span><br><span class="line">    Node *tmp = v-&gt;left;</span><br><span class="line">    v-&gt;left = tmp-&gt;right;</span><br><span class="line">    tmp-&gt;right = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();</span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>在树中插入给定权值的点。<br>根据权值在满足二叉搜索树性质的适当叶子结点进行插入，如果插入使得堆的性质被破坏，则进行旋转。特别地，如果在插入的过程中检查到键值相同的已经在树上的节点，则直接使其的副本数量+1。（代码中副本的数量用 $num$ 表示）。<br>代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        v = newNode();</span><br><span class="line">        v-&gt;val = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;</span><br><span class="line">        v-&gt;num++;</span><br><span class="line">        v-&gt;pushUp();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;</span><br><span class="line">        insert(v-&gt;left, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;left-&gt;pri) &#123;</span><br><span class="line">            rightRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(v-&gt;right, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;right-&gt;pri) &#123;</span><br><span class="line">            leftRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除树中给点权值的点。  </p>
<ul>
<li>如果要删除的点为叶子结点，直接删除即可；  </li>
<li>如果不是叶子结点，旋转到叶子结点再执行删除；  </li>
<li>如果该点没有左子树或右子树，将该点删除，使其唯一的子树移动到该点即可。特别的是，如果该权值的点有多个，只需使其副本数量减少。  </li>
</ul>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            v-&gt;num--;</span><br><span class="line">            v-&gt;pushUp();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                v = v-&gt;right;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                v = v-&gt;left;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left-&gt;pri &gt; v-&gt;right-&gt;pri) &#123;</span><br><span class="line">                rightRotate(v);</span><br><span class="line">                remove(v-&gt;right, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                leftRotate(v);</span><br><span class="line">                remove(v-&gt;left, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;</span><br><span class="line">            remove(v-&gt;left, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(v-&gt;right, value);</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, pri;<span class="comment">//val为简直，pri为随机生成的数据，使其满足堆的性质</span></span><br><span class="line">    <span class="keyword">int</span> size, num;<span class="comment">//size表示以该点为根的子树的大仙，num表示该点的副本数</span></span><br><span class="line">    Node *left, *right;<span class="comment">//左右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;<span class="comment">//更新size</span></span><br><span class="line">        size = num;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            size += left-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            size += right-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; poor[MAXN], *tail = poor, *root;<span class="comment">//poor是根据数据范围而定的内存池，优化new的过程</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">newNode</span><span class="params">()</span> </span>&#123;<span class="comment">//用内存池取代new操作</span></span><br><span class="line">    Node *ret = ++tail;</span><br><span class="line">    ret-&gt;val = <span class="number">0</span>, ret-&gt;pri = rand();</span><br><span class="line">    ret-&gt;size = ret-&gt;num = <span class="number">1</span>;</span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//左旋，通过引用更改其祖先的信息</span></span><br><span class="line">    Node *tmp = v-&gt;right;</span><br><span class="line">    v-&gt;right = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();<span class="comment">//更新结点信息，非常重要，不要忘写</span></span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//右旋</span></span><br><span class="line">    Node *tmp = v-&gt;left;</span><br><span class="line">    v-&gt;left = tmp-&gt;right;</span><br><span class="line">    tmp-&gt;right = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();</span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;<span class="comment">//当前结点为空，直接插入</span></span><br><span class="line">        v = newNode();</span><br><span class="line">        v-&gt;val = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;<span class="comment">//value已经在树里了，直接更新副本数量和子树大小</span></span><br><span class="line">        v-&gt;num++;</span><br><span class="line">        v-&gt;pushUp();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;<span class="comment">//根据BST的性质决定走左子树还是右子树</span></span><br><span class="line">        insert(v-&gt;left, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;left-&gt;pri) &#123;<span class="comment">//如果不满足堆的性质就旋上来</span></span><br><span class="line">            rightRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(v-&gt;right, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;right-&gt;pri) &#123;</span><br><span class="line">            leftRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//空点直接结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;<span class="comment">//当前点就是要删除的，接着进行分类讨论</span></span><br><span class="line">        <span class="keyword">if</span> (v-&gt;num &gt; <span class="number">1</span>) &#123;<span class="comment">//有多个副本，直接修改该点的信息</span></span><br><span class="line">            v-&gt;num--;</span><br><span class="line">            v-&gt;pushUp();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//没有副本，要删除该点</span></span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left == <span class="literal">NULL</span>) &#123;<span class="comment">//如果左右子树中有一个为空，则直接使另一颗取代v的位置</span></span><br><span class="line">                v = v-&gt;right;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                v = v-&gt;left;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left-&gt;pri &gt; v-&gt;right-&gt;pri) &#123;<span class="comment">//如果不为空则要旋转到叶子结点，此时根据左右子树的pri关系来决定旋转方向</span></span><br><span class="line">                rightRotate(v);</span><br><span class="line">                remove(v-&gt;right, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                leftRotate(v);</span><br><span class="line">                remove(v-&gt;left, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v-&gt;pushUp();<span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//当前点不是的值不是value,则向子树进行操作，</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;</span><br><span class="line">            remove(v-&gt;left, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(v-&gt;right, value);</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;pushUp();<span class="comment">//别忘了更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(Node *v, <span class="keyword">int</span> rank)</span> </span>&#123;<span class="comment">//根据给定的排名，求出对应排名的值</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;<span class="comment">//记录左子树的大小，即为比v小的值的数量</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = v-&gt;left-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rank &lt;= s) &#123;<span class="comment">//说明此时要找到排名为rank的点在左子树中</span></span><br><span class="line">        <span class="keyword">return</span> getValue(v-&gt;left, rank);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rank &lt;= s + v-&gt;num) &#123;<span class="comment">//v的排名即为rank，返回v的值</span></span><br><span class="line">        <span class="keyword">return</span> v-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getValue(v-&gt;right, rank - s - v-&gt;num);<span class="comment">//在右子树中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRank</span><span class="params">(Node *v, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//求给定值的排名</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = v-&gt;left-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;  <span class="comment">//利用BST的性质判断该往哪里走</span></span><br><span class="line">        <span class="keyword">return</span> getRank(v-&gt;left, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == v-&gt;val) &#123;<span class="comment">//v即为所求</span></span><br><span class="line">        <span class="keyword">return</span> s + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s + v-&gt;num + getRank(v-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPre</span><span class="params">(Node *v, <span class="keyword">int</span> value, <span class="keyword">int</span> &amp;pre)</span> </span>&#123;<span class="comment">//求值value的前驱</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;/特判</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val &lt; value) &#123;<span class="comment">//该点值比value小，可能为前驱</span></span><br><span class="line">        pre = v-&gt;val;</span><br><span class="line">        getPre(v-&gt;right, value, pre);<span class="comment">//使前驱尽可能大</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        getPre(v-&gt;left, value, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSucc</span><span class="params">(Node *v, <span class="keyword">int</span> value, <span class="keyword">int</span> &amp;succ)</span> </span>&#123;<span class="comment">//求值value的后继</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val &gt; value) &#123;</span><br><span class="line">        succ = v-&gt;val;</span><br><span class="line">        getSucc(v-&gt;left, value, succ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        getSucc(v-&gt;right, value, succ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;<span class="comment">//读入优化</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = ret * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> n, ans;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        <span class="keyword">switch</span>(x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                insert(root, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                remove(root, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, getRank(root, y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, getValue(root, y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                getPre(root, y, ans);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                getSucc(root, y, ans);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>Treap</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图学习笔记</title>
    <url>/2018/07/05/bipartite-graph/</url>
    <content><![CDATA[<p>二分图又称二部图，是图论中一种特殊模型。对于一个无向图，如果可以把他的顶点分为两个互不相交的子集，并且图中的每一条边，所关联的两个顶点都分别属于两个不同的顶点集，则称该图为二分图。显然二分图中不存在奇数环，如果出现的话无法被划分到任何集合里。  </p>
<a id="more"></a>

<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p>通过 $dfs$ 或者 $bfs$ 对一张图染色（即染色法，共有两种颜色），对于每一条边，使其两个节点的颜色不同。当一个点的颜色已经被确定时，该结点的颜色与当前应该染的颜色冲突，则说明这张图不是二分图。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> color)</span> </span>&#123;<span class="comment">//u为当前遍历到的结点，color为该点应该染的颜色，用1， 2来表示</span></span><br><span class="line">    <span class="keyword">if</span> (col[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[u] != color) <span class="keyword">return</span>;<span class="comment">//说明这张图不是二分图</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        col[u] = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        dfs(v, <span class="number">3</span> - color);<span class="comment">//边的两个端点颜色不同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。（如图三红边）<br><img src="https://i.loli.net/2018/07/05/5b3ddcb139508.png" alt="1.png"> <img src="https://i.loli.net/2018/07/05/5b3ddcb144938.png" alt="2.png">   <img src="https://i.loli.net/2018/07/05/5b3ddcb145f58.png" alt="3.png">   <img src="https://i.loli.net/2018/07/05/5b3ddcb14751d.png" alt="4.png"><br>相应的，属于「匹配」的边为匹配边，不属于匹配的边为为匹配的边。与匹配边相连的点为匹配点，反之则为未匹配点。  </p>
<h2 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h2><p>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。例如图四所示的红边，注意一张图的最大匹配方案不一定唯一。 （见图四） </p>
<h2 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h2><p>对于一张图的某个匹配来说，如果该图的所有点都是匹配点，那么称该匹配为该图的「完美匹配」（图四）。显然，完美匹配一定是最大匹配。  </p>
<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p>一种求最大匹配的算法。  </p>
<h2 id="交叉路"><a href="#交叉路" class="headerlink" title="交叉路"></a>交叉路</h2><p>从一个未匹配点出发，<strong>依次</strong>经过未匹配边、匹配边、未匹配边、匹配边……最终到达另一个点的路径。特别的，一条未匹配边与两个未匹配点组成的路径也是交叉路  </p>
<h2 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h2><p>最后一个端点为未匹配点的交叉路。特别的，一条未匹配边与两个未匹配点组成的路径也是增广路。增广路的首尾两条边都是未匹配边，首尾两个点都是未匹配点，并且边数一定是奇数。既然是奇数，那么增广路中的未匹配边一定比匹配边多一条。  </p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>根据增广路中未匹配边比匹配边多一条的性质，那么只要把增广路中的边的身份翻转，得到的新的匹配中的边数就会多一。因此匈牙利算法实质上是在不断地找增广路来改进当前的匹配。由此得出，最大匹配中一定不存在增广路，如果有增广路的话，该匹配就可以改进，就不是最大匹配了。  </p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>从二分图的一边开始，以每个点为起点进行 $dfs$ 或者 $bfs$ ，每当搜索到一条增广路时，结束搜索。那么显然以一个点为起点只能找到一条增广路。每找到一条增广路，匹配数便加一。注意实际实现的时候并没有把边标记为匹配边与未匹配边。连接两个匹配点的路径显然是匹配边。  </p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;<span class="comment">//vis数组用来标记该点有没有在本次dfs中被遍历过</span></span><br><span class="line">            vis[v] = <span class="literal">true</span>;<span class="comment">//更改状态，标记为遍历过</span></span><br><span class="line">            <span class="keyword">if</span> (!pre[v] ||dfs(pre[v])) &#123;<span class="comment">//pre数组记录该匹配边中的另一个点，</span></span><br><span class="line">                <span class="comment">//如果为空的话显然就是一条增广路。如果不为空，则遍历该数组中记录的点，并返回能否找到增广路</span></span><br><span class="line">                pre[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//已经找到增广路了，结束遍历，返回结果。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//未找到增广路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><p><strong>最大匹配数</strong>：最大匹配的边数。<br><strong>最小点覆盖数</strong>：尽可能少地选择一些点，使得图中任意一条边都至少有一个顶点被选择。<br><strong>最小路径覆盖数</strong>：对于一张 $DAG$ ，选取最少的简单路径数，使得每个顶点只属于一条路径。路径可以仅由一个点组成。换言之，按照这样的路径能遍历到所有的点，且每个点仅被遍历一次。<br><strong>最小边覆盖</strong>：选取最少的边，使得图中任意一个点都是最小边覆盖集的邻接顶点，一条边只能覆盖两条边。（特别地，孤立点无法被任何边覆盖，所以含孤立点的图不存在边覆盖）<br><strong>最大独立集</strong>：选取最多的点，这些点彼此之间没有连边。<br><strong>最大团</strong>：当且仅当该子图是一张完全图（任意两个点之间都有边的图），且该子图不属于该图中的任何完全子图时为该图的最大团</p>
<h3 id="最小点覆盖数"><a href="#最小点覆盖数" class="headerlink" title="最小点覆盖数"></a>最小点覆盖数</h3><p>最小点覆盖数 = 最大匹配数（ $\text{König}$ 定理）。<br>证明过于复杂，因此不在此贴出，请自行百度。</p>
<h3 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h3><p>最大独立集的点数 = 点数 - 最大匹配数（或者最小点覆盖数）<br>这条定理可以用反证法证明，需要一点前置知识，阅读以下内容之前请务必理解如何证明最小点覆盖数 = 最大匹配这条定理，以及二分图的最小路径覆盖点集如何求出。<br>如果你已经准备好了，那请继续阅读。<br>把二分图的最小点覆盖集删除之后，剩余的点之间如果边，那么最小点覆盖集必然无法覆盖这些边。但是最小点覆盖集必然可以覆盖所有的边，所以上述与最小点覆盖集的性质冲突，故不成立，即最小点覆盖集以外的点之间必然没有边。所以：最大独立集的点数 = 点数 - 最小点覆盖数。又因为最小点覆盖数 = 最大匹配得，所以：最大独立集的点数 = 点数 - 最大匹配数。</p>
<h3 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h3><p>最小路径覆盖数 = 点数 - 相应二分图的最大匹配数<br>把无向图的每个点拆成两个，分别属于构造出的二分图的两边（对于点 $x$ ，由 $x$ 拆得的左边的点与右边的点分别为$x_1， x_2$）。设有边 $(u, v)$ ，那么在二分图中便有边 $(u_1, v_2)$ 。因为原图是 $DAG$ ， 那么每条路径上的点除终点之外，都有且仅有一个后继。假设点都各自是一条路径，那么路径数与点数相同。二分图中每有一条匹配边，便会使一个点有且仅有一个后继。这也意味着这个点不能成为路径的终点。而路径有唯一的终点，所以每有一个匹配，路径便会少一。那么便能得到：最小路径覆盖数 = 点数 - 相应二分图的最大匹配数   </p>
<h3 id="最小边覆盖"><a href="#最小边覆盖" class="headerlink" title="最小边覆盖"></a>最小边覆盖</h3><p>对于二分图：</p>
<p>最小边覆盖数 = 点数 - 最大匹配数 = 最大独立集数。</p>
<p>优先选择匹配边，因为选取最大匹配集中的点都会让两个点被覆盖。然后剩下的所有的边要么是连接两个匹配点，要么连接一个匹配点和一个未匹配点，选取后者。就是说选取完匹配边之后，再对于每个未覆盖点选取一条连接该点和一个覆盖点的边，这样的边集即为最小边覆盖集。</p>
<p>所以一开始给出的式子也就可以推出了。</p>
<p>最大匹配数 + （点数 - 2 * 最大匹配数） = 点数 - 最大匹配数</p>
<p>（感谢<a href="https://blog.aor.sd.cn/">wyh</a>聚聚用几句话就给我讲懂了证明）<img src="https://i.loli.net/2018/11/28/5bfe7f3bc0925.png" alt="img"></p>
<h3 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h3><p>最大团点数 = 点数 - 相应的补图的最大匹配数<br>构造出该无向图的补图后，最大团实际上就是补图的最大独立集， 故有：最大团点数 = 点数 - 相应的补图的最大匹配数。</p>
]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijsktra算法</title>
    <url>/2018/01/20/dijkstra/</url>
    <content><![CDATA[<p>Dijkstra算法是一种用于求最短路径的算法，用于求一个节点到其他所有节点的最短路径。与其他的最短路径算法一样，都采用松弛操作，并且运用了贪心的思想。适用于处理不存在负边权的稀疏图，算法的时间复杂度为 $O(N^2)$ ,采用堆优化后可以达到 $O(N\log N)$ 。</p>
<a id="more"></a>
<p>下面给出堆优化写法，题目参考<a href="https://www.luogu.org/problemnew/show/1339">Heat Wave</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    <span class="keyword">bool</span> used;</span><br><span class="line">    Edge *firstEdge;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *s, Node *t, <span class="keyword">int</span> w) : s(s), t(t), w(w), next(s-&gt;firstEdge)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t, <span class="keyword">const</span> <span class="keyword">int</span> &amp;w)</span> </span>&#123;</span><br><span class="line">    node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s], &amp;node[t], w);</span><br><span class="line">    node[t].firstEdge = <span class="keyword">new</span> Edge(&amp;node[t], &amp;node[s], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        node[i].dist = INT_MAX;</span><br><span class="line">        node[i].used = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Node*&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Node*&gt; &gt;, greater&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Node*&gt; &gt; &gt; heap;</span><br><span class="line">    heap.push(<span class="built_in">make_pair</span>(node[s].dist = <span class="number">0</span>, &amp;node[s]));</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty()) &#123;</span><br><span class="line">        Node *u = heap.top().second;</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;used) <span class="keyword">continue</span>;</span><br><span class="line">        u-&gt;used = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge *e = u-&gt;firstEdge; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e-&gt;t-&gt;dist &gt; e-&gt;w + u-&gt;dist) &#123;</span><br><span class="line">                e-&gt;t-&gt;dist = e-&gt;w + u-&gt;dist;</span><br><span class="line">                heap.push(<span class="built_in">make_pair</span>(e-&gt;t-&gt;dist, e-&gt;t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node[t].dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dijkstra(n, s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>【SDOI2009】HH的项链</title>
    <url>/2018/11/18/hh-necklace/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.org/problemnew/show/P1972">LuoguP1972</a></p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$\text{HH}$  有一串由各种漂亮的贝壳组成的项链。$\text{HH}$ 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。$\text{HH}$ 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行：一个整数 $\text{N}$，表示项链的长度。</p>
<p>第二行：$\text{N}$  个整数，表示依次表示项链中贝壳的编号（编号为 $0$ 到 $1000000$ 之间的整数）。</p>
<p>第三行：一个整数 $\text{M}$，表示 $\text{HH}$ 询问的个数。</p>
<p>接下来 $\text{M}$  行：每行两个整数，$\text{L}$  和 $\text{R}（1  \leq L \leq R \leq N）$，表示询问的区间。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>$\text{M}$ 行，每行一个整数，依次表示询问对应的答案。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 3 5</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">2 6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>数据范围：</p>
<p>对于 $100 %$ 的数据，$ n \leq 500000, m \leq 500000$  </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意很简单明了，就是求区间不同的数的个数，可以离线</p>
<p>主席树当然是可以做的，主席树可以在线解决。<del>但是我好久没写了，而且常数还大</del>，莫队也可以跑过去</p>
<p>但是有点大材小用，树状数组离线就够了</p>
<p>分析一下题目的性质，不难看出，如果查询的区间 $[l, r]$ 内有重复的数，这个重复的数只会在一个位置被计算贡献，其他位置的贡献要去掉。</p>
<p>先把询问读进来，然后按照右端点的位置升序排序，用树状数组记录贡献，某一个询问的答案用树状数组查询一下前缀和差分一下就可以得到。但是这样是会重复计算相同的数的贡献的，考虑去重。</p>
<p>对于一个数 $\text{w}$，如果它在序列中多次出现，那么我们按照这样排序之后，只需要保留最靠右的 $\text{w}$ 的贡献，因为对于一次右端点在 $\text{w}$ 右边的查询，这次查询要么不包含任意一个 $\text{w}$，要么包含一个或者多个。我们只保留最靠右的那一个的贡献，就会消除掉重复的贡献，故思路是对的。开一个数组 $\text{last[i]}$ 表示 $\text{i}$ 最后一次出现的位置，如果出现过就去掉前面的贡献</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = l; i &lt;= r; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[MAXN], t[MAXN], last[MAXN], now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x))</span><br><span class="line">        t[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x))</span><br><span class="line">    	ret += t[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(r) - sum(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pro</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pro &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; other.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ask[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;ask[i].l, &amp;ask[i].r);</span><br><span class="line">        ask[i].pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(ask + <span class="number">1</span>, ask + m + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        rep(j, now, ask[i].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[a[j]]) add(last[a[j]], <span class="number">-1</span>);</span><br><span class="line">            add(j, <span class="number">1</span>);</span><br><span class="line">            last[a[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ask[i].pos] = query(ask[i].l, ask[i].r);</span><br><span class="line">        now = ask[i].r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>离线</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>【LuoguP1402】酒店之王</title>
    <url>/2018/11/18/king-of-hotels/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1402">LuoguP1402</a></p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>XX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。</p>
<p>有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间，吃到喜欢的菜）。</p>
<p>这里要怎么分配，能使最多顾客满意呢？</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行给出三个正整数表示 $\text{n,p,q}( \leq 100)$。</p>
<p>之后 $\text{n}$ 行，每行$\text{p}$ 个数包含 $0$ 或 $1$，第 $\text{i}$ 个数表示喜不喜欢第 $\text{i}$ 个房间（ $1$ 表示喜欢，$0$ 表示不喜欢）。</p>
<p>之后 $\text{n}$ 行，每行 $\text{q}$ 个数，表示喜不喜欢第 $\text{i}$ 道菜。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>最大的顾客满意数。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2 2</span><br><span class="line">1 0</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>好像就是两个二分图，和在一块是一个三分图？（姑且这么叫吧）</p>
<p>愣是没想出来怎么用二分图做</p>
<p>但是最大流做法还是很显然的</p>
<p>因为每个人的贡献最大是 $1$，所以要把表示人的点拆点，拆成两个，然后在表示同一个人的两个点之间连一条容量为 $1$ 的边</p>
<p>首先要拆点，一共有六排点，一个超级源点在最左边，$\text{p}$ 个表示房间的点在第二排，$\text{n}$ 个人拆点之后在第三排和第四排，第五排是表示菜的 $\text{q}$ 个点，最后一排是超级汇点</p>
<p>细节上，根据限制，超级源点要向所有表示房间的点连一条容量为 $1$ 的边，所有表示菜的点向超级汇点连一条容量为 $1$ 的边。如果某个人喜欢谋个房间，便从这个房间向这个人连一条容量为 $1$ 的边；如果某个人喜欢某道菜，便从这个人向这道菜连一条容量为 $1$ 的边。</p>
<p>最后跑一下最大流就好了，我用的是 $\text{Dinic}$ </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> * <span class="number">4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">300</span> * <span class="number">300</span> * <span class="number">3</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, flow, next;</span><br><span class="line">&#125; edge[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cur[MAXN], cnt = <span class="number">1</span>, tot;</span><br><span class="line"><span class="keyword">int</span> deep[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">    edge[cnt].flow = flow;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line">        deep[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    deep[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">            <span class="keyword">if</span> (!deep[v] &amp;&amp; edge[e].flow) &#123;</span><br><span class="line">                deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> limit = INT_MAX)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !limit) <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;e = cur[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; (f = dfs(v, t, <span class="built_in">std</span>::min(limit, edge[e].flow)))) &#123;</span><br><span class="line">            ans += f;</span><br><span class="line">            limit -= f;</span><br><span class="line">            edge[e].flow -= f;</span><br><span class="line">            edge[e ^ <span class="number">1</span>].flow += f;</span><br><span class="line">            <span class="keyword">if</span> (!limit) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s, t)) ret += dfs(s, t);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p, q;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;p, &amp;q);</span><br><span class="line">    tot = <span class="number">2</span> * n + p + q + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        add(p + i, p + n + i, <span class="number">1</span>);</span><br><span class="line">        add(p + n + i, p + i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                add(j, p + i, <span class="number">1</span>);</span><br><span class="line">                add(p + i, j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= q; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                add(p + n + i, p + <span class="number">2</span> * n + j, <span class="number">1</span>);</span><br><span class="line">                add(p + <span class="number">2</span> * n + j, p + n + i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++) add(<span class="number">0</span>, i, <span class="number">1</span>), add(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) add(p + <span class="number">2</span> * n + i, tot, <span class="number">1</span>), add(tot, p + <span class="number">2</span> * n + i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dinic(<span class="number">0</span>, tot));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title>noip2018总结与反思</title>
    <url>/2018/11/18/noip2018/</url>
    <content><![CDATA[<p>NOIP2018游记</p>
<a id="more"></a>

<h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>从上午8点左右，一直颠到下午1点才到昌邑一中。</p>
<p>前一天机房里就疯狂出橙，我死活不出= =，坐车的时候zzh还大喊“我出橙了！还是金橙！”</p>
<p>我：“mmp，欧吃矛”</p>
<p>团长说我没出橙说明我把rp攒到noip考场上了</p>
<p>食堂里的饭和SDSC2018的时候的饭基本没什么变化，还是那么油腻以及有大量菌类= =</p>
<p>去主楼抽签之前，我奶我自己在昌邑一中考试，结果抽到了潍坊工业学校= =，还TM是除了备用考场之外最后一个考场= =</p>
<p>下午在一个都是鸽子的亭子周围和好多人面基了，我也忘了牌子上写的是什么了，姑且就叫它鸽子亭吧(手动滑稽)</p>
<p>以下是我认识的鸽亭面基大会的成员：</p>
<p>wqy,tqc,rqy,hzy,cjc,tqc,yt,dzm,refun,hc</p>
<p>晚上试机的时候，巴车延迟了= =</p>
<p>在等巴车的时候据说还有人在签到，吐槽一下昌邑一中的办事效率</p>
<p>比较庆幸的是考试用win7，还和wqy神犇一个考场</p>
<p>键盘键程超级短，前一天还在用青轴的我感到极度不适。</p>
<p>试机的时候写了一发线段树和lis，旁边的小哥在写最短路</p>
<p>回去的时候在群里看到sqy神仙试机30分钟的时间就写出了rbt ，orz</p>
<p>回宿舍洗刷完就关灯躺床上打算睡觉了，但是前几天睡的比较晚，生物钟调不过来，然后聊天聊到11点多才睡</p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>早上不知道因为什么四点来钟就行了，躺床上想再睡会但是一直睡不着，盖着被还是感觉很冷。</p>
<p>无比清醒地躺倒6点多才和大家一起起床吃饭</p>
<p>吃完早餐去餐厅楼下买了一瓶景甜，一罐红牛，一瓶脉动，很怕自己考场上睡着，再超市找了好几圈才找到红牛</p>
<p>耽误了时间，差点没赶上班车。。。</p>
<p>开始考试的时候挺紧张的，虽然今年只是练兵，无关紧要，但还是想要考好</p>
<p>T1拿到题就出来怎么做了，然后没想好拿什么维护就直接开始写线段树= =，虽然十分钟就写完了，但是怕被卡常还是老老实实换成了st表。换成st表反而还调了很久= =，维护下标没写过几次</p>
<p>T2读完题没想出来是什么意思，然后读了两三遍之后发现就是删去里面可以被其他数若干倍和表示的就可以了。然后满脑子数论，“大凯的疑惑？”。然后想到一个数的倍数，两个数的倍数和，三个数的倍数和……</p>
<p>听团长昨晚在宿舍里提了一嘴裴蜀定理，`然后就满脸自闭地推式子，发现并不会做= =，死活想不到是个完全背包</p>
<p>然后打了前三十分开始看下一题。</p>
<p>T3读错题了，考场上没看到要首尾相接，但还是觉得是个二分答案，但是考场上愣是没想到怎么检验，我还以为像去年普及组T4一样dp检验，但是没想出来方程和转移。部分分写了链和m=1的40分。m=1的部分分一开始还写假了，输出边权和= =，最后十分钟才发现选一条最长的，然后收卷前五分钟写完树的直径= =</p>
<p>还有就是链上的二分答案我怕写挂，是这么写的（跑民间数据的时候稳得一批）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = min, r = sum, mid;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check1(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (check1(i)) &#123;</span><br><span class="line">            mid = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mid);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>出考场之后wqy告诉我贪心检验，记一下最长剩余权值= =</p>
<p>Day1：100 + 30 + 40滚粗</p>
<p>晚上在宿舍里满脑子Day2翻盘</p>
<p>和昨晚一样早躺在床上但是睡不着</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>早上6点来钟就醒了，手机闹钟过了几分钟才响</p>
<p>照例买了红牛和景甜，但是没买脉动，三瓶太多喝不了</p>
<p>等颓子ycy看番，差点真赶不上班车，迟到×2，团长和ycy的车已经出发了</p>
<p>在考场上心态挺崩的，满脑子想着Day2翻盘</p>
<p>T1树的那部分分挺好拿的，优先队列维护出边dfs就可以了，考场上几分钟写完，时间复杂的O(nlogn)</p>
<p>然后开始想基环树的那40分，满脑子想着怎么贪心，没看到枚举断边就可以过，一个半小时之后觉得再想就亏了，扔了开始看T2和T3，这时候其实就很紧张了</p>
<p>T2题面很长我还没读懂，但貌似是个数学题我就觉得不太可做，读了两三遍之后扔了开始看T3，事后发现很多神仙也放弃T2了</p>
<p>T3我一开始读错题了，还以为是个裸的二分图染色，敲完之后开始带样例，小样例带过，大样例挂了之后发现不对劲了。</p>
<p>挂掉之后有点不知所措，看着数据约定的表格不知道该写哪一部分，几分钟之后才回过神来写前五十分。</p>
<p>前五十分是每次询问跑一遍dp，貌似和没有上司的舞会差不多。考场上写挂了，样例都带不过去，心态崩到不知道怎么调试，干等着肉眼看到收卷</p>
<p>Day2:60滚粗</p>
<p>赛后民间数据测的成绩都在230-245这个范围</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol>
<li>整体上心态很差，太紧张了，由于心态引起了很多失误</li>
<li>D1T1没分析好需求就开始写线段树，浪费10分钟</li>
<li>做D1T2的时候不太灵活，没想到完全背包，说明对于完全背包还是不够熟练，白丢70分</li>
<li>D1T3很尽力地打了部分分，但是读错题还是说明心态太差以及不够细心</li>
<li>D2T1很紧张地没根据时间复杂度做题，结果浪费啷个小时</li>
<li>D2T2直接略过好像是对的，我确实是做不出来。数学太差以后要恶补</li>
<li>D2T3心态崩到写不出暴力</li>
</ol>
<p>主要的问题还是说考场上太紧张了，现在分析一下，D2T3的50分暴力和D1T2的70分正解我状态好其实是可以拿到的。</p>
<p>不过好在这次除了D2T3的暴力，其他的都没有写挂（至少民间数据是这样）</p>
<p>回去的路上团长给我说如果这是场模拟赛的话，我肯定心态就会好很多，分数也会高很多</p>
<p>想想挺有道理的，今年NOIP我最大的问题就是心态。考试的时候想的太多了，太想拿成绩证明一下自己，然后负担很重紧张也就在所难免。</p>
<p>希望明年能放松点好好发挥吧。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>看一眼这篇文章，写得有点乱</p>
<p>鄙人文笔不好，而且思维还有点混乱，但还是想写一篇总结&amp;游记&amp;反思性质的文章纪念一下第一次参加NOIP提高组，所以还是发表挂上吧。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>【LYOI】20180916T2 Solution</title>
    <url>/2018/09/16/solution/</url>
    <content><![CDATA[<p>Solution for LYOI contest【2018.9.16.T2】</p>
<a id="more"></a>

<p>题目的意思就是说给你一些截距为 $0$ 的二次函数，然后让你求对于特定的 $x$ ，最大的函数值是多少。</p>
<p>首先二次函数是抛物线，不太好做。</p>
<p>其实可以把这些二次函数拆成两条一次函数，两条函数关于 $x$ 轴对称，分别对应 $x$ 为为正负两种情况。</p>
<p>然后你就有了两个有若干一次函数的平面直角坐标系。</p>
<p>然后只需要求对于不同的 $x$ 的取值范围，哪段函数更优就可以了，对于正负两种情况分别维护上凸壳和下凸壳（貌似是斜率优化 $\text{QAQ}$ ）。</p>
<p>其实这个单调队列就可以实现，过程有点像初中数学里给你两个直线，求 $x$ 的哪些取值范围哪条直线的函数值更大。常见套路是求直线的交点，据此判断大小，求凸壳也是如此，凸壳上的点都是直线的交点嘛。（个人感觉凸壳就是分段函数QAQ）</p>
<p>对于两个一次函数$ax+b$和$a’x+b’$，其交点的横坐标可以用一元一次方程求得。</p>
<p>$$ax+b=a’x+b’$$ </p>
<p>$$ax-a’x=b’-b$$ </p>
<p>$$x=\frac{b’-b}{a-a’}$$ </p>
<p>如果求上凸壳的话，显然 $x$ 的值越大，这条直线的斜率就越大，也就更优。下凸壳也是类似的道理。</p>
<p>算法流程如下：</p>
<ul>
<li>对这些直线按照斜率和截距从小到大的顺序排序，其中斜率的优先级大于截距</li>
<li>然后用单调队列求出上凸壳。</li>
<li>对于任意的 $x$ ，只需要判断其正负，然后在凸壳上二分查找，即可求得最优值。</li>
</ul>
<p>具体实现见代码(这么丑的代码当然不是我写的QAQ)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> U unsigned</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for(R int i = a;i &lt;= b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RFOR(i,a,b) for(R int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(i,a) memset(i,a,sizeof(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BR printf(<span class="meta-string">&quot;--------------------\n&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO&#123;<span class="comment">//fread,读入优化，不需要看</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> OUT_SIZE 100000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">    <span class="keyword">bool</span> IOerror=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (p1==pend)&#123;</span><br><span class="line">            p1=buf; pend=buf+fread(buf,<span class="number">1</span>,BUF_SIZE,<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">if</span> (pend==p1)&#123;IOerror=<span class="number">1</span>;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;<span class="keyword">return</span> ch==<span class="string">&#x27; &#x27;</span>||ch==<span class="string">&#x27;\n&#x27;</span>||ch==<span class="string">&#x27;\r&#x27;</span>||ch==<span class="string">&#x27;\t&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">        <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">        <span class="keyword">for</span> (;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">        <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">        <span class="keyword">for</span> (;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> ll</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> OUT_SIZE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> BUF_SIZE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> size1,size2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Values</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Values &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == other.a) <span class="keyword">return</span> b &lt; other.b;<span class="comment">//注意优先级</span></span><br><span class="line">        <span class="keyword">return</span> a &lt; other.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;v1[MAXN],v2[MAXN],s1[MAXN],s2[MAXN];<span class="comment">//函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,Q;</span><br><span class="line"><span class="comment">// y=ax+b;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Values v[],Values s[],<span class="keyword">int</span> &amp;size)</span></span>&#123;<span class="comment">//单调队列求凸壳</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v + <span class="number">1</span>,v + N + <span class="number">1</span>);<span class="comment">//先排序</span></span><br><span class="line">    FOR(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        <span class="keyword">while</span>((size &gt;= <span class="number">1</span> &amp;&amp; s[size].a == v[i].a) || (size &gt;= <span class="number">2</span> &amp;&amp; (<span class="number">1l</span>l * (s[size<span class="number">-1</span>].b - s[size].b) * (v[i].a - s[size<span class="number">-1</span>].a)) &gt;= (<span class="number">1l</span>l * (s[size<span class="number">-1</span>].b - v[i].b) * (s[size].a - s[size<span class="number">-1</span>].a))))<span class="comment">//去重以及通过直线交点的横坐标判断哪条直线更优</span></span><br><span class="line">            size--;</span><br><span class="line">        s[++size] = v[i];<span class="comment">//入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">val</span><span class="params">(<span class="keyword">const</span> Values &amp;u,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//求函数值</span></span><br><span class="line">    <span class="keyword">return</span> (LL)u.a * x + u.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">find_max</span><span class="params">(Values s[],<span class="keyword">int</span> size,<span class="keyword">int</span> x)</span></span>&#123;在凸包上二分查找最优值</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = size;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(val(s[mid],x) &gt; val(s[mid + <span class="number">1</span>],x))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)val(s[l],x)*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(N);read(Q);</span><br><span class="line">    FOR(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        read(v1[i].a);read(v1[i].b);</span><br><span class="line">        v2[i].a = -v1[i].a;v2[i].b = -v1[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    pre(v1,s1,size1);</span><br><span class="line">    pre(v2,s2,size2);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;read(x);</span><br><span class="line">        <span class="keyword">if</span>(!x)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,-find_max(s2,size2,x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,find_max(s1,size1,x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>solution</tag>
        <tag>斜率优化</tag>
        <tag>计算几何</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
        <tag>单调队列</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】ST表</title>
    <url>/2018/07/16/st/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ST表，稀疏表，用于求解经典的RMQ问题。即区间最值问题。基于倍增思想，利用递推的方式预处理，支持高效的查询，不支持修改  </p>
<a id="more"></a>



<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">22</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        f[i][<span class="number">0</span>] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> LC = (<span class="keyword">int</span>)(<span class="built_in">std</span>::<span class="built_in">log</span>(n)/<span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= LC; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">std</span>::max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> k = (<span class="keyword">int</span>)(<span class="built_in">std</span>::<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">std</span>::max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模板</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>【LYOI】20180923 Solution</title>
    <url>/2018/09/23/solution2018123/</url>
    <content><![CDATA[<p>Solution for LYOI contest 【2018.9.23】</p>
<a id="more"></a>

<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个由括号组成的字符串，有若干次询问，每次询问要求输出从 $[l,r]$ 中选出若干括号，组成的最长的括号序列的长度。（注意是序列不是子串，序列可以不连续）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据面向数据范围编程的原则，发现 $O(m\log_2n)$ 的算法可以过。</p>
<p>区间问题很容易让人想到线段树，实际上本题符合线段树维护数据的原则，不过需要在查询的时候使用一个技巧。</p>
<p>线段树的每个节点维护三个信息，分别是本区间内未匹配的左括号数量，未匹配的右括号的数量，以及完成匹配的括号的对数，分别用 $lm,rm,num$ 来表示。</p>
<p>这类问题的合并是核心，维护了上述三个信息之后不难想到如何合并。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">std</span>::min(lc-&gt;lm, rc-&gt;rm);<span class="comment">//求出左儿子未匹配的左括号和右儿子未匹配的右括号的最小值</span></span><br><span class="line">        num = lc-&gt;num + rc-&gt;num + t;<span class="comment">//合并之后这些括号可以匹配</span></span><br><span class="line">        lm = lc-&gt;lm + rc-&gt;lm - t;<span class="comment">//去掉新匹配的括号</span></span><br><span class="line">        rm = lc-&gt;rm + rc-&gt;rm - t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个问题是如何查询</p>
<p>查询 $[l,r]$ 这个区间的答案时，这个区间会被分成若干个长度为 $\text{2}$ 的整数次幂的区间。线段树递归合并的顺序是从左到右的，那么我们可以记录已经处理的当前区间左边区间的 $lm,rm,num$ ，再把当前区间和左边这个区间合并即可。</p>
<p>贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, SegmentTree *&amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; r == right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">std</span>::min(k-&gt;lm, rm);<span class="comment">//和pushUp一模一样的合并操作</span></span><br><span class="line">            k-&gt;num = k-&gt;num + num + t;</span><br><span class="line">            k-&gt;lm = k-&gt;lm + lm - t;</span><br><span class="line">            k-&gt;rm = k-&gt;rm + rm - t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;query(left, right, k);<span class="comment">//线段树我就不讲了吧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;query(left, right, k);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;query(left, mid, k), rc-&gt;query(mid + <span class="number">1</span>, right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> lm, rm, num;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> newNode(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode(l, r, build(l, mid), build(mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">std</span>::min(lc-&gt;lm, rc-&gt;rm);</span><br><span class="line">        num = lc-&gt;num + rc-&gt;num + t;</span><br><span class="line">        lm = lc-&gt;lm + rc-&gt;lm - t;</span><br><span class="line">        rm = lc-&gt;rm + rc-&gt;rm - t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[l] == <span class="string">&#x27;(&#x27;</span>) lm++;</span><br><span class="line">            <span class="keyword">else</span> rm++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lc-&gt;init(), rc-&gt;init();</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, SegmentTree *&amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; r == right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">std</span>::min(k-&gt;lm, rm);</span><br><span class="line">            k-&gt;num = k-&gt;num + num + t;</span><br><span class="line">            k-&gt;lm = k-&gt;lm + lm - t;</span><br><span class="line">            k-&gt;rm = k-&gt;rm + rm - t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;query(left, right, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;query(left, right, k);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;query(left, mid, k), rc-&gt;query(mid + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *root, pool[MAXN &lt;&lt; <span class="number">1</span>], *tail = pool, *k;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;l = l, ret-&gt;r = r, ret-&gt;mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    ret-&gt;lm = ret-&gt;rm = ret-&gt;num = <span class="number">0</span>;</span><br><span class="line">    ret-&gt;lc = lc, ret-&gt;rc = rc;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    k = newNode(<span class="number">1</span>, n, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    root = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    root-&gt;init();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        k-&gt;lm = k-&gt;rm = k-&gt;num = <span class="literal">false</span>;</span><br><span class="line">        root-&gt;query(l, r, k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k-&gt;num &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $\text{n}$ 个收益都为 $\text{1}$ 的物品，以及 $\text{n}$ 组 $b_i,k_i$ ，表示对于第 $\text{i}$ 个物品，可以花$b_i+k_i$个金币进行购买，其中 $b_i$ 比较珍贵，要尽可能少使用。</p>
<p>给定 $\text{m}$ 种购买途径，每种途径只能用一次。 $a_i$ 表示第 $\text{i}$ 种途径需要花费的金币数量。</p>
<p>求最多能购买的物品数量和满足购买的物品最多的前提下最小的 $b_i$ 消耗和。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>对于第一问，把 $a_i$ 排序，然后依次处理。</p>
<p>对于 $a_i$ ，显然使用这种途径去买能买的物品中$b_i+k_i$最小的是最优的，这样就求出了最大物品数。</p>
<p>对于第二问，将使用的购买方法取出，按ai从大到小依次贪心，在物品中选择可以使用当前购买方法的且 $k_i$ 最大的物品，可以用堆实现 。</p>
<p>具体细节看代码吧。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b, k;</span><br><span class="line">&#125; h[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.k + a.b &lt; b.k + b.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(h + <span class="number">1</span>, h + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="built_in">std</span>::sort(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i].k + h[i].b &gt;= a[cnt] &amp;&amp; cnt &lt;= m) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cnt);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (h[i].k + h[i].b &lt; a[cnt] &amp;&amp; cnt &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            sum += <span class="built_in">std</span>::max(a[cnt--] - q.top(), <span class="number">0</span>);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h[i].k + h[i].b &gt;= a[cnt]) &#123;</span><br><span class="line">            q.push(h[i].k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += <span class="built_in">std</span>::max(a[cnt--] - q.top(), <span class="number">0</span>);</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 $s,p$ 两个字符串，求在 $s$ 串中删除若干字符后的 $p$ 串的数量。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>无脑 $\text{DP}$ 啊QAQ</p>
<p>设 $f[i][j]$ 表示 $s$ 的前 $i$ 个字符中，删去 $j$ 个字符之后 $p$ 串的最大数量。</p>
<p>设 $w[i]$ 表示从 $s$ 的第 $i$ 个字符开始，最小的可以通过删除某些字符来得到 $p$ 串的字符串长度。</p>
<p>转移也很显然了</p>
<ul>
<li><p>不删除，对答案无影响</p>
<p>$$ f[i+1][j]=\max(f[i+1][j],f[i][j]) $$ </p>
</li>
<li><p>删除，对答案无影响</p>
<p>$$ f[i+1][j+1]=\max(f[i+1][j+1],f[i][j]) $$ </p>
</li>
<li><p>删除，对答案有影响</p>
<p>$$ f[i+w[i]][j+w[i]-|p|]=\max(f[i+w[i])[j+w[i]-|p|],f[i][j]+1) $$ </p>
</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e3</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN], p[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN], w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, s, p);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), m = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        w[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == p[t]) t++;</span><br><span class="line">            <span class="keyword">if</span> (t == m) &#123;</span><br><span class="line">                w[i] = j - i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][j] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][j], f[i][j]);</span><br><span class="line">            f[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][j + <span class="number">1</span>], f[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; <span class="number">0</span>)</span><br><span class="line">                f[i + w[i]][j + w[i] - m] = <span class="built_in">std</span>::max(f[i][j] + <span class="number">1</span>, f[i + w[i]][j + w[i] - m]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, f[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][n]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树</tag>
        <tag>solution</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>【JSOI2014】松鼠的新家</title>
    <url>/2018/07/15/squirrel/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.org/problemnew/show/P3258">Luogu P3258</a>  </p>
<a id="more"></a>   

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>非常裸的树上路径权值修改与单点查询，可以用树剖实现，也可以树上差分。    </p>
<h3 id="代码（O2）"><a href="#代码（O2）" class="headerlink" title="代码（O2）"></a>代码（O2）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>;</span><br><span class="line"><span class="function">Edge *<span class="title">newEdge</span><span class="params">(Node *s, Node *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = ret * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum, tag;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left == right ? newTree(left, right, <span class="literal">NULL</span>, <span class="literal">NULL</span>) : newTree(left, right, build(left, mid), build(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        tag += delta;</span><br><span class="line">        sum += (r - l + <span class="number">1</span>) * delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">            lc-&gt;cover(tag);</span><br><span class="line">            rc-&gt;cover(tag);</span><br><span class="line"></span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; right == r) &#123;</span><br><span class="line">            cover(delta);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">            lc-&gt;modify(left, right, delta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            rc-&gt;modify(left, right, delta);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lc-&gt;modify(left, mid, delta);</span><br><span class="line">            rc-&gt;modify(mid + <span class="number">1</span>, right, delta);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; right == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;query(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> rc-&gt;query(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;query(left, mid) + rc-&gt;query(mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *tree, poor[MAXN &lt;&lt; <span class="number">1</span>], *tail = poor;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;l =l, ret-&gt;r = r;</span><br><span class="line">    ret-&gt;lc = lc, ret-&gt;rc = rc;</span><br><span class="line">    ret-&gt;sum = ret-&gt;tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *firstEdge;</span><br><span class="line">    Node *parent, *top, *son;</span><br><span class="line">    <span class="keyword">int</span> dfn, depth, size;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *s, *t;</span><br><span class="line">    Edge *next;</span><br><span class="line">&#125; po[MAXN &lt;&lt; <span class="number">1</span>], *last = po;</span><br><span class="line"></span><br><span class="line"><span class="function">Edge *<span class="title">newEdge</span><span class="params">(Node *s, Node *t)</span> </span>&#123;</span><br><span class="line">    Edge *ret = ++last;</span><br><span class="line">    ret-&gt;s = s, ret-&gt;t = t;</span><br><span class="line">    ret-&gt;next = s-&gt;firstEdge;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    node[s].firstEdge = newEdge(&amp;node[s], &amp;node[t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    u-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = u-&gt;firstEdge; e; e = e-&gt;next) &#123;</span><br><span class="line">        Node *v = e-&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(v != u-&gt;parent) &#123;</span><br><span class="line">            v-&gt;parent = u;</span><br><span class="line">            v-&gt;depth = u-&gt;depth + <span class="number">1</span>;</span><br><span class="line">            dfs(v);</span><br><span class="line">            u-&gt;size += u-&gt;size;</span><br><span class="line">            <span class="keyword">if</span> (!u-&gt;son || u-&gt;son-&gt;size &lt; v-&gt;size) u-&gt;son = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ts =  <span class="number">0</span>;</span><br><span class="line">    u-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!u-&gt;parent || u != u-&gt;parent-&gt;son) u-&gt;top = u;</span><br><span class="line">    <span class="keyword">else</span> u-&gt;top =  u-&gt;parent-&gt;top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;son) split(u-&gt;son);</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = u-&gt;firstEdge; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t-&gt;parent == u &amp;&amp; e-&gt;t != u-&gt;son) &#123;</span><br><span class="line">            split(e-&gt;t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;top != v-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;top-&gt;depth &lt; v-&gt;top-&gt;depth) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        tree-&gt;modify(u-&gt;top-&gt;dfn, u-&gt;dfn, d);</span><br><span class="line">        u = u-&gt;top-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;dfn &gt; v-&gt;dfn) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">    tree-&gt;modify(u-&gt;dfn, v-&gt;dfn, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;top != v-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;top-&gt;depth &lt; v-&gt;top-&gt;depth) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        ret += tree-&gt;query(u-&gt;top-&gt;dfn, u-&gt;dfn);</span><br><span class="line">        u = u-&gt;top-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;dfn &gt; v-&gt;dfn) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">    ret += tree-&gt;query(u-&gt;dfn, v-&gt;dfn);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        read(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        read(u), read(v);</span><br><span class="line">        addEdge(u, v);</span><br><span class="line">        addEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(&amp;node[<span class="number">1</span>]);</span><br><span class="line">    split(&amp;node[<span class="number">1</span>]);</span><br><span class="line">    tree = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> last = a[<span class="number">1</span>];</span><br><span class="line">    tree-&gt;modify(node[last].dfn, node[last].dfn, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tree-&gt;modify(node[last].dfn, node[last].dfn, <span class="number">-1</span>);</span><br><span class="line">        modify(&amp;node[last], &amp;node[a[i]], <span class="number">1</span>);</span><br><span class="line">        last = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tree-&gt;modify(node[last].dfn, node[last].dfn, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree-&gt;query(node[i].dfn, node[i].dfn));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树上差分</tag>
        <tag>树链剖分</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>【NOIP2015】运输计划</title>
    <url>/2018/08/02/transportation-plan/</url>
    <content><![CDATA[<p>给定一颗边权为非负整数的数，以及一些树上路径。选择一条边吗，使其边权变成 $0$ ， 求树上边权和最大的路径的最小值。</p>
<a id="more"></a>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.org/problemnew/show/P2680">LuoguP2680</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先求出给定的这些路径边权和， $dfs$ 的时候预处理出每个点到根节点的路径的边权和，用 $sum$ 表示。用倍增 $LCA$ 求出给定路径端点的最近公共祖先，用 $x, y$ 表示路径端点， $lca$ 表示最近公共祖先，那么这些路径的长度就是</p>
<p>$$sum[x] + sum[y] - 2 * sum[lca]$$ </p>
<p>然后对这些路径按照边权和，以递减的顺序排序。然后二分答案。其单调性体现在，答案越小，这条边权将要变成 $0$ 的边的边权就要越大，就要被更多的路径所包含。对于所有边权和大于答案的路径，当且仅当边权将要修改的那条边被这些路径都包含，答案才有成立的可能。当满足上一个条件，并且边权和最大的路径的边权减去这条边的边权小于或等于答案时，这个答案就是成立的。</p>
<p>怎么求这些路径的公共部分呢？</p>
<p>如果你能联想到序列的话，就不难想到可以使用差分来求。可以把树上的路径拆分成两条链来看。对于树上的每个点，这个点的标记表示的是连接该点与其父节点的边的标记，因为边不容易检索与维护。然后对其子树递归求和即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, t, w, next;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Path</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, lca, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Path &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;len &gt; x.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[MAXN], dif[MAXN], f[MAXN][<span class="number">22</span>], deep[MAXN], sum[MAXN], max;</span><br><span class="line"><span class="keyword">int</span> n, m, num;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = ret * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    edge[cnt].s = u;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = pre;</span><br><span class="line">    deep[u] = deep[pre] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span> &amp;&amp; deep[u] - (<span class="number">1</span> &lt;&lt; i) &gt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        sum[v] = sum[u] + edge[e].w;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &gt; deep[b]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">21</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[f[b][i]] &gt;= deep[a]) b = f[b][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">21</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[a][i] == f[b][i]) <span class="keyword">continue</span>;</span><br><span class="line">        a = f[a][i];</span><br><span class="line">        b = f[b][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, u);</span><br><span class="line">        dif[u] += dif[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dif[u] == num) max = <span class="built_in">std</span>::max(max, sum[u] - sum[f[u][<span class="number">0</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dif, <span class="number">0</span>, <span class="keyword">sizeof</span>(dif));</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    max = <span class="number">-2147483647</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; p[i].len &gt; mid; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        dif[p[i].x]++;</span><br><span class="line">        dif[p[i].y]++;</span><br><span class="line">        dif[p[i].lca] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (max == <span class="number">-2147483647</span> || p[<span class="number">1</span>].len - max &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(u), read(v), read(w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        read(p[i].x), read(p[i].y);</span><br><span class="line">        p[i].lca = Lca(p[i].x, p[i].y);</span><br><span class="line">        p[i].len = sum[p[i].x] + sum[p[i].y] - sum[p[i].lca] * <span class="number">2</span>;</span><br><span class="line">        r = <span class="built_in">std</span>::max(r, p[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = binarySearch();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>差分</tag>
        <tag>倍增</tag>
        <tag>二分答案</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】树链剖分</title>
    <url>/2018/06/23/tree-chain-split/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>树链剖分是一种维护树上路径信息的算法，它将一棵树剖分成一些不相交的链，保证每个点在且仅在一条链上。并通过线段树、树状数组等数据结构维护信息。</p>
<a id="more"></a>  

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P3384">题目链接</a></h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>重结点：子树中结点数目最多的结点；<br>轻节点：父亲节点中除了重结点以外的结点；<br>重边：父亲结点和重结点连成的边；<br>轻边：父亲节点和轻节点连成的边；<br>重链：由多条重边连接而成的路径；<br>轻链：由多条轻边连接而成的路径；    </p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>把整棵树划分成许多条链，使每个节点都在唯一的链上，对每一条链维护一棵线段树，把在树上的操作转移到线段树上。  </p>
<p>树链剖分的策略是轻重边路径剖分，这种策略可以保证整棵树上的轻边和链的数量都不超过 $O(\log n)$ 。    </p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="剖分"><a href="#剖分" class="headerlink" title="剖分"></a>剖分</h2><p>剖分由两次 $dfs$ 组成，第一遍求出每个节点的大小、父节点、深度、重结点，即 $size, fa, dep, son$ 数组。  </p>
<p>第二遍 $dfs$ 求出每个结点所在的链、 $dfn$ 序，即 $top, dfn$ 数组。（本模板对链的信息除了链顶结点外并没有需要，因此 $top$ 数组实际上记录的是该结点所在链的链顶结点的下标，具体用处见下文）。</p>
<p>对于一个结点，如果该结点不是其父节点的重结点或该结点为根节点，则创建一条以该结点为链顶结点的链，否则该节点与其父节点属于同一条链。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>使用线段树对这棵树进行维护，以 $dfn$ 为新的下标。</p>
<h2 id="查询与修改路径信息"><a href="#查询与修改路径信息" class="headerlink" title="查询与修改路径信息"></a>查询与修改路径信息</h2><p>修改或查询 $u, v$ 之间路径上的信息，采取以下策略。<br>首先假设 $u$ 的深度更大，那么修改或查询 $u$ 所在链的链顶结点到 $u$ 这条路径上所有结点的信息，然后将 $u$ 跳到其链顶结点的父节点。重复以上步骤直到 $u$ 与 $v$ 在同一条链上为止。最后修改或查询两点间上结点路径的信息。</p>
<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>不难看出，上述查询或修改路径的过程，实际上是分别修改或查询了 $u$ 到两点间最近公共祖先的路径与 $v$ 到两点间最近公共祖先的路径，所以不难看出，只需去掉查询与修改路径信息的过程，即可求得最近公共祖先。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, next;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum, add;</span><br><span class="line">&#125; t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root, HA, w[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt, head[MAXN];</span><br><span class="line"><span class="keyword">int</span> size[MAXN], son[MAXN], fa[MAXN], pos[MAXN], dep[MAXN], top[MAXN], dfn[MAXN], ts;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = flag * ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    fa[u] = father;</span><br><span class="line">    dep[u] = dep[father] + <span class="number">1</span>;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span>(v == father) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt; size[v]) &#123;</span><br><span class="line">            maxSize = size[v];</span><br><span class="line">            son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tops)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++ts;</span><br><span class="line">    top[u] = tops;</span><br><span class="line">    pos[ts] = u;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) dfs2(son[u], tops);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span>(v != son[u] &amp;&amp; fa[v] == u) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    t[x].l = left;</span><br><span class="line">    t[x].r = right;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        t[x].sum = w[pos[left]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">    t[x].sum = (t[x &lt;&lt; <span class="number">1</span>].sum + t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    t[x].add = (t[x].add + d) % HA;</span><br><span class="line">    t[x].sum = (t[x].sum + (t[x].r - t[x].l + <span class="number">1</span>) * d) % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].add &amp;&amp; t[x].l != t[x].r) &#123;</span><br><span class="line">        cover(x &lt;&lt; <span class="number">1</span>, t[x].add);</span><br><span class="line">        cover(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, t[x].add);</span><br><span class="line">        t[x].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].sum = (t[x &lt;&lt; <span class="number">1</span>].sum + t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].l == l &amp;&amp; t[x].r == r) &#123;</span><br><span class="line">        cover(x, d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushDown(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span>, l, mid, d);</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, d);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUp(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].l == l &amp;&amp; t[x].r == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[x].sum % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    pushDown(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (query(x &lt;&lt; <span class="number">1</span>, l, mid) + query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveUpdate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[a] != top[b]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]] &lt; dep[top[b]]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">        update(<span class="number">1</span>, dfn[top[a]], dfn[a], d);</span><br><span class="line">        a = fa[top[a]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[a] &gt; dfn[b]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">    update(<span class="number">1</span>, dfn[a], dfn[b], d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solveQuery</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[a] != top[b]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]] &lt; dep[top[b]]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">        ret = (ret + query(<span class="number">1</span>, dfn[top[a]], dfn[a])) % HA;</span><br><span class="line">        a = fa[top[a]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[a] &gt; dfn[b]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">    ret = (ret + query(<span class="number">1</span>, dfn[a], dfn[b])) % HA;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeUpdate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    update(<span class="number">1</span>, dfn[u], dfn[u] + size[u] - <span class="number">1</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeQuery</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">1</span>, dfn[u], dfn[u] + size[u] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Read(n), Read(m), Read(root), Read(HA);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        Read(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Read(u), Read(v);</span><br><span class="line">        add(u, v);</span><br><span class="line">        add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(root, <span class="number">0</span>);</span><br><span class="line">    dfs2(root, root);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> c, x, y, z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        Read(c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            Read(x), Read(y), Read(z);</span><br><span class="line">            solveUpdate(x, y, z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span>) &#123;</span><br><span class="line">            Read(x), Read(y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, solveQuery(x, y));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">3</span>) &#123;</span><br><span class="line">            Read(x), Read(y);</span><br><span class="line">            treeUpdate(x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">4</span>) &#123;</span><br><span class="line">            Read(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, treeQuery(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【NOIP2010】引水入城</title>
    <url>/2018/08/31/water/</url>
    <content><![CDATA[<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://www.luogu.org/problemnew/show/P1514">LuoguP1514</a></p>
<a id="more"></a>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>以第一行的每个点为起点进行 $\text{dfs}$ ，被遍历过的点不要作为起点。这样就能求出那些点能被遍历到。 </p>
<p>如果最后一行不能被全部遍历，那就统计一下没有遍历到的点，然后输出答案。</p>
<p>问题在于最后一行如果可以被全部遍历到，如何最小化蓄水厂的个数。其实如果可以被全部遍历到的话，每个蓄水厂所能到达的最后一行的点是连续的，也就是说一条线段。在此简单地证明一下：</p>
<p>假设有一个点 $y$ 高于其左右两个点，并且左右的点都可以被 $x$ 蓄水厂到达，并且其上方的这个点可以被某个蓄水厂 $z$ 到达。那么现在分成了两种情况。</p>
<ul>
<li>如果 $y$ 上方的点的高度低于 $y$ 那么显然是无解的， $y$ 点无法到达。</li>
<li>如果 $y$ 上方的点的高度高于 $y$ ，那么 $z$ 显然可以到达 $y$ 以及其左右的点，那么 $x$ 其实一定可以与 $z$ 可以到达的某个点相交，也就是说 $x$ 一定可以到达交点之后的 $z$ 能到达的所有的点，故 $x$ 可以到达 $y$ 。</li>
</ul>
<p>得证。</p>
<p> 那么就变成了经典的线段覆盖问题，只需要贪心地让右端点更靠右就可以了。因为数据范围小，所以其实不用优先队列也可以通过。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e2</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[MAXN][MAXN], r[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> high[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN], flag;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">        <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (tx &gt;= <span class="number">1</span> &amp;&amp; tx &lt;= n &amp;&amp; ty &gt;= <span class="number">1</span> &amp;&amp; ty &lt;= m &amp;&amp; !vis[tx][ty] &amp;&amp; high[x][y] &gt; high[tx][ty]) &#123;</span><br><span class="line">            dfs(tx, ty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tx &gt;= <span class="number">1</span> &amp;&amp; tx &lt;= n &amp;&amp; ty &gt;= <span class="number">1</span> &amp;&amp; ty &lt;= m &amp;&amp; high[x][y] &gt; high[tx][ty]) &#123;</span><br><span class="line">            l[x][y] = <span class="built_in">std</span>::min(l[x][y], l[tx][ty]);</span><br><span class="line">            r[x][y] = <span class="built_in">std</span>::max(r[x][y], r[tx][ty]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;high[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(l));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        l[n][i] = r[n][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[<span class="number">1</span>][i]) dfs(<span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[n][i]) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[<span class="number">1</span>][i] &lt;= left) &#123;</span><br><span class="line">                maxr = <span class="built_in">std</span>::max(maxr, r[<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = maxr + <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>【NOI2010】超级钢琴</title>
    <url>/2018/06/02/%E3%80%90NOI2010%E3%80%91%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小Z是一个小有名气的钢琴家，最近C博士送给了小Z一架超级钢琴，小Z希望能够用这架钢琴创作出世界上最美妙的音乐。</p>
<p>这架超级钢琴可以弹奏出 $n$ 个音符，编号为 $1$ 至 $n$ 。第 $i$ 个音符的美妙度为 $A_i$ ，其中 $A_i$ 可正可负。</p>
<p>一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于 $L$ 且不多于 $R$ 。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。</p>
<p>小Z决定创作一首由k个超级和弦组成的乐曲，为了使得乐曲更加动听，小Z要求该乐曲由k个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小Z想知道他能够创作出来的乐曲美妙度最大值是多少。</p>
<a id="more"></a>

<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输入第一行包含四个正整数 $n,k,L,R$ 。其中 $n$ 为音符的个数， $k$ 为乐曲所包含的超级和弦个数， $L$ 和 $R$ 分别是超级和弦所包含音符个数的下限和上限。</p>
<p>接下来 $n$ 行，每行包含一个整数 $A_i$ ，表示按编号从小到大每个音符的美妙度。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输出只有一个整数，表示乐曲美妙度的最大值。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">-6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.    音符1 ~ 2，美妙度为3 + 2 &#x3D; 5</span><br><span class="line">2.    音符2 ~ 3，美妙度为2 + (-6) &#x3D; -4</span><br><span class="line">3.    音符3 ~ 4，美妙度为(-6) + 8 &#x3D; 2</span><br><span class="line">4.    音符1 ~ 3，美妙度为3 + 2 + (-6) &#x3D; -1</span><br><span class="line">5.    音符2 ~ 4，美妙度为2 + (-6) + 8 &#x3D; 4</span><br></pre></td></tr></table></figure>

<p>最优方案为：乐曲由和弦1，和弦3，和弦5组成，美妙度为5 + 2 + 4 = 11。</p>
<p><img src="https://cdn.luogu.org/upload/pic/2609.png" alt="数据范围"></p>
<p>所有数据满足： $-1000 \leq A_i \leq 1000, 1 \leq L \leq R \leq n$ 且保证一定存在满足要求的乐曲。</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P2048">题目链接</a></h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>整理一下这个题的题意，其实就是求序列长度在 $[l, r]$ 范围内的的前 $k$ 大序列的和。</p>
<p>最暴力的想法当然是枚举序列的长度，然后枚举端点，再维护一个记录前k大序列值的数组，每次求到一个新的序列和，暴力更新。</p>
<p>既然是最暴力的想法，当然可以优化，而这道题优化之后就能得到正解。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>既然是求序列长度和，聪明的你有没有想到什么奇技淫巧呢？</p>
<p>这…这不是前缀和吗？</p>
<p>我们可以预处理一个前缀和的数组，这样知道长度和端点之后就可以 $O(1)$ 地求序列和了。</p>
<h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>暴力解法中，有提到枚举区间长度和端点对吧？</p>
<p>我们可以进行另一个优化。</p>
<p>先枚举左端点，这样我们就可以根据左端点的下标和给出的 $l, r$ 来求出右端点的范围了。</p>
<p>根据前缀和的定义，已知左端点之后，只需要最大化从 $1$ 到右端点的前缀和即可。</p>
<p>然而我们已经知道右端点的范围了，那么这就是一个 $RMQ$ 问题。可以用代码简单的 $ST$ 表来解决这个问题，只需进行 $O(n \log_2(n))$ 复杂度的预处理，即可进行 $O(1)$ 时间复杂度的查询。 <del>你非要写线段树也不拦着你。 </del></p>
<h3 id="优化三"><a href="#优化三" class="headerlink" title="优化三"></a>优化三</h3><p>对于每次通过枚举端点求出的序列，定义一个四元组 $(s, t, l, r)$ , $, t$ 分别表示左右端点的下标， $l, r$ 表示右端点的范围。</p>
<p>现在的暴力算法，只剩下求前 $k$ 大的序列这个操作没有优化过了。实际上，动态求前 $k$ 大，堆这种数据结构是再方便不过了，况且$C++$的 $STL$ 库里还有优先队列这种方便的东西。</p>
<p>利用堆以区间长度为关键字，在堆中维护这些四元组。此时的堆为大根堆。</p>
<h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><p>这样的话，先枚举序列的，再利用求在右端点范围内的前缀和最大值，再用堆维护优化三中提到的四元组。</p>
<p>然后，边弹出堆顶，边插入新的四元组 $(s, sum_{max}, l,  t - 1)​$ 和$(s, sum_{max}, t + 1, r)​$。其中 $max​$ 表示区间内前缀和最大的端点的下标。因为如果不插入的话只是以每个点为左端点求最大值，然而这 $k​$ 个序列的左端点可以重复，所以需要把这个右端点扣掉后再压入堆。弹出堆顶 $k​$ 次，和即为答案。这一步</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">22</span>], sum[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, k, L, R;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, l, r, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[t] - sum[s - <span class="number">1</span>] &lt; sum[x.t] - sum[x.s - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;Node&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[x] &gt; sum[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> mx(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;k, &amp;L, &amp;R);</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + w;</span><br><span class="line">        f[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">19</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            f[i][j] = mx(f[i][j - <span class="number">1</span>],  f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + L - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">std</span>::min(n, i + R - <span class="number">1</span>);</span><br><span class="line">        heap.push((Node) &#123;i, i + L - <span class="number">1</span>, right, query(i + L - <span class="number">1</span>, right)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; k) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        Node g = heap.top(); heap.pop();</span><br><span class="line">        ans += sum[g.t] - sum[g.s - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> q1 = query(g.l, g.t - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> q2 = query(g.t + <span class="number">1</span>, g.r);</span><br><span class="line">        <span class="keyword">if</span>(~q1) heap.push((Node) &#123;g.s, g.l, g.t - <span class="number">1</span>, q1&#125;);</span><br><span class="line">        <span class="keyword">if</span>(~q2) heap.push((Node) &#123;g.s, g.t + <span class="number">1</span>, g.r, q2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>ST表</tag>
        <tag>堆</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>【USACO5.3】校园网Network of Schools</title>
    <url>/2018/03/17/%E3%80%90USACO5.3%E3%80%91%E6%A0%A1%E5%9B%AD%E7%BD%91Network%20of%20Schools/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 B 在 A 学校的分发列表中， A 也不一定在 B 学校的列表中。</p>
<p>你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。</p>
<a id="more"></a>  

<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包括一个整数 N：网络中的学校数目$(2 &lt;= N &lt;= 100)$。学校用前 N 个正整数标识。</p>
<p>接下来 N 行中每行都表示一个接收学校列表（分发列表）。第 i+1 行包括学校 i 的接收学校的标识符。每个列表用 0 结束。空列表只用一个 0 表示。  </p>
<h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><p>你的程序应该在输出文件中输出两行。  </p>
<p>第一行应该包括一个正整数：子任务 A 的解。  </p>
<p>第二行应该包括子任务 B 的解。  </p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 3 0</span><br><span class="line">4 5 0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>

<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P2746">题目链接</a></h3><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>读完题目之后显然能看出来需要缩点。通过Tarjan算法缩完点之后能得到一张有向无环图。<br>那么问题的答案显然就是求从至少几个点出发能到达所有的点和至少加入几条边来使整个图构成一个强连通分量。<br>第一个问题的答案显然是入度为0的强连通分量的数量。因为只有从这个入度为0的点开始遍历才能遍历到这个点，而入度不为0的点显然是可以以其他点为起点遍历到。所以答案是正确的。<br>对于第二个问题，需要从强连通分量的定义来入手。强连通分量的任意两个点都能相互到达，这也就意味着所有点的出度和入度最起码为1。所以只需要对入度为0的点的数量和出度为0的点的数量取 $max$ 就是答案了。<br>值得一提的是需要特判只有一个点的情况。  </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; edge[MAXN * (MAXN - <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN], chu[MAXN], ru[MAXN], sccTime, sccSize, scc[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inStack[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].s = s;</span><br><span class="line">    edge[cnt].t = t;</span><br><span class="line">    edge[cnt].next = head[s];</span><br><span class="line">    head[s] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++sccTime;</span><br><span class="line">    <span class="built_in">stack</span>.push(u);</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(inStack[v]) &#123;</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u]) &#123;</span><br><span class="line">        sccSize++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            inStack[x] = <span class="literal">false</span>;</span><br><span class="line">            scc[x] = sccSize;</span><br><span class="line">            <span class="keyword">if</span>(u == x) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            <span class="keyword">if</span>(!t) <span class="keyword">break</span>;</span><br><span class="line">            add(i, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e = head[i]; e; e = edge[e].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = edge[e].t;</span><br><span class="line">            <span class="keyword">if</span>(scc[i] != scc[t]) &#123;</span><br><span class="line">                chu[scc[i]]++;</span><br><span class="line">                ru[scc[t]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cntChu = <span class="number">0</span>, cntRu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sccSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chu[i] == <span class="number">0</span>) cntChu++;</span><br><span class="line">        <span class="keyword">if</span>(ru[i] == <span class="number">0</span>) cntRu++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sccSize == <span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cntRu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">std</span>::max(cntChu, cntRu));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>【SCOI2005】互不侵犯King</title>
    <url>/2018/02/10/%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AFKing/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。  </p>
<a id="more"></a>  

<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）  </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>所得的方案数  </p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题看完题目描述显然就是一道搜索或者是动态规划，观察数据范围暴搜显然是会超时的。所以我们直接想想动态规划的思路。很多人看到这道题的时候会下意识地想到八皇后问题，实际上这两道题确实有共同之处。我们可以像八皇后那道题一样逐行处理。经过思考我们可以很容易地出状态转移方程。只需把能转移到当前状态的状态累加即可。需要注意的是第三维下标应用了状态也压缩的技巧来存储当前这行国王是如何摆放的。  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">10</span>][<span class="number">100</span>][<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop_count</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s &amp; <span class="number">1</span>) ans++;</span><br><span class="line">        s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="keyword">bool</span>(s &amp; (s &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> !ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid2</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> ss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="keyword">bool</span> (s &amp; ss) || (s &amp; (ss &gt;&gt; <span class="number">1</span>)) || (s &amp; (ss &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> !ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t1 = <span class="number">0</span>; t1 &lt; l; t1++)</span><br><span class="line">                <span class="keyword">if</span>(is_valid(t1) &amp;&amp; pop_count(t1) &lt;= j)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t2 = <span class="number">0</span>; t2 &lt; l; t2++)</span><br><span class="line">                        <span class="keyword">if</span>(is_valid(t2) &amp;&amp; is_valid2(t1, t2))&#123;</span><br><span class="line">                            f[i][j][t1] += f[i<span class="number">-1</span>][j-pop_count(t1)][t2];</span><br><span class="line">                            <span class="comment">/*DEBUG(f[i][j][t1])*/</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; l; t++)</span><br><span class="line">        <span class="keyword">if</span>(is_valid(t))</span><br><span class="line">            ans += f[n][k][t] <span class="comment">/*DEBUG(ans)*/</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算（一）</title>
    <url>/2018/07/20/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>计算机中的所有数据都是以二进制的形式存储的，位运算就是直接对这些二进制数据进行操作，因此处理速度非常快。  </p>
<a id="more"></a>

<h2 id="基本的位运算"><a href="#基本的位运算" class="headerlink" title="基本的位运算"></a>基本的位运算</h2><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a><code>&amp;</code></h3><p>按位与运算，当两个位都为<code>1</code>时，结果才为<code>1</code>。<br>例如<code>11 &amp; 13</code>，这两个数转化成二进制之后分别是<code>1011</code>与<code>1101</code>,那么对这两个数进行<code>&amp;</code>操作的结果就是<code>1001</code>,转化为十进制就是<code>9</code>。    </p>
<h3 id=""><a href="#" class="headerlink" title="|"></a><code>|</code></h3><p>按位或运算，两个位都为<code>0</code>时，结果才为<code>0</code>，否则为<code>1</code>。<br>例如<code>10 | 9</code>，转化为二进制后为<code>1010</code>与<code>1001</code>，那么结果就是<code>1011</code>,转化为十进制就是<code>11</code>。  </p>
<h3 id="-1"><a href="#-1" class="headerlink" title="^"></a><code>^</code></h3><p>按位异或运算，两个位相同时为<code>0</code>，不同为<code>1</code>。<br>例如<code>9 ^ 12</code>，转化为二进制之后就是<code>1001</code>与<code>1100</code>，那么结果就是<code>0101</code>，忽略前导<code>0</code>之后的结果就是<code>101</code>，转化为十进制就是<code>5</code>。  </p>
<h3 id="-2"><a href="#-2" class="headerlink" title="~"></a><code>~</code></h3><p>按位取反操作，<code>0</code>变<code>1</code>，<code>1</code>变<code>0</code>。<br>例如<code>~10</code>，转化为二进制就是<code>1010</code>，结果是<code>0101</code>，忽略前导<code>0</code>后为<code>101</code>，转化为十进制就是<code>5</code>。    </p>
<h3 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a><code>&lt;&lt;</code></h3><p>左移运算，将各个二进制位全部左移若干位，超出长度的高位丢弃（长度由变量类型决定），低位补<code>0</code>。<br>例如<code>5 &lt;&lt; 2</code>，把<code>5</code>转化为二进制为<code>101</code>，再把<code>101</code>左移<code>2</code>位，低位补<code>0</code>，结果就是<code>10100</code>，转化为十进制为<code>20</code>。    </p>
<h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a><code>&gt;&gt;</code></h3><p>右移运算，将各个二进制位全部右移若干位，丢弃低位超出的不分。<br>例如<code>10 &gt;&gt; 2</code>，把<code>10</code>转化为二进制为<code>1010</code>，右移<code>2</code>位，丢弃低位的<code>10</code>，结果为<code>10</code>，转化为十进制为<code>2</code>。    </p>
<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>【HNOI2009】最小环</title>
    <url>/2018/02/23/%E6%9C%80%E5%B0%8F%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P3199">【HNOI2009】最小环</a></p>
<a id="more"></a>  

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求输出边权平均值最小的环的平均值，再看一眼数据范围，不难联想到我们可以二分答案。剩下的就是如何去check我们的答案。我们让所有边减去一个我们二分平均值，如果存在负环，说明这个答案是成立的。什么算法能用来求负环呢？显而易见是SPFA！值得一提的的地方是常规的队列实现的SPFA用来求负环效率十分低下，因此需要用DFS版的SPFA来求负环。  </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE = <span class="number">10005</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; e[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt = <span class="number">0</span>, n, m;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-9</span>, dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN], flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i != <span class="number">0</span>; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(dis[v] &gt; dis[x] + e[i].w - mid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[v] = dis[x] + e[i].w - mid;</span><br><span class="line">            spfa(v, mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        spfa(i,mid);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lf&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e5</span>, r = <span class="number">1e5</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(r-l &gt; eps) &#123;</span><br><span class="line">        mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8f\n&quot;</span>, mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分答案</tag>
        <tag>分数规划</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
