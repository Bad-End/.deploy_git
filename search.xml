<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【模板】01背包</title>
    <url>/01bags/</url>
    <content><![CDATA[<p>   f[i]表示背包已用i容量时能得到的最大价值，value[i]表示第i个物体的价值，size[i]表示第i个物品所要占据的背包容量（或者说是重量、时间之类的）。那么我们的决策就是要不要把当前处理的物品放入背包中。我们可以得到方程$f[i]=\max(f[i],f[i-size[i]]+value[i])$。题目链接<a href="https://www.luogu.org/problemnew/show/P1048">采药</a><br>   <a id="more"></a>  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> value[MAXN], size[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;size[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= size[i]; j--) &#123;</span><br><span class="line">            f[j] = max(f[j], f[j - size[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模板</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.10.1笔记</title>
    <url>/2020.10.1/</url>
    <content><![CDATA[<p>2020.10.1笔记</p>
<a id="more"></a>

<h1 id="模拟赛题解"><a href="#模拟赛题解" class="headerlink" title="模拟赛题解"></a>模拟赛题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>简单找规律博弈题。</p>
<p>首先特判掉 $n \leq 3$ 的情况，因为可以一步走完。</p>
<p>对于一般的 $Case$，$n$ 为奇数先手必胜，$n$ 为偶数则手里都是偶数的玩家必胜。</p>
<p>只要证明 $n$ 为偶数的情况之后就可以证明奇数的情况了。</p>
<p>$n$ 为偶数时，手里都是偶数的玩家总可以在倒数第二步打出点数为 $n$ 的牌，多抢得一次出牌机会来取得胜利。</p>
<p>$n$ 为奇数时，先手手中若都是奇数，打出手中最小的牌之后就相当于偶数的情况了；<br>反之，总有一个时刻后手打出 $n$，此时转变为偶数的情况。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>直接正着刷的话，每次刷需要考虑之前被改掉的位置，维护的复杂度不对。</p>
<p>考虑反着刷，每一行每一列只刷一次，刷多次直接忽略掉（因为会被覆盖），再记录行和列分别已经被刷了多少次，每次刷计算增量即可。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>直接使用<code>std::nth_element</code>，复杂度为 $O(nq)$。</p>
<p>也可以求出所有交点，把询问和交点按照时间排个序，暴力交换即可。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>易得一个一个消掉必然是不劣的，但是两个序列不等长，所以最优策略一定是每次一个序列只消掉一段，另一个序列消掉一个。</p>
<p>直接设 $f_{i, j}$ 表示第一个序列消掉 $i$ 个，另一个消掉 $j$ 个的最小代价。</p>
<p>转移枚举新开一段还是接上上一段。</p>
<p>或者写一个不太优美的方程，然后前缀最小值优化一下。</p>
<p>$$f_{i, j} = \min_{k&lt;i} \lbrace f_{k, j - 1} + (pre_i - pre_k-i+k) \times b_j\rbrace$$</p>
<p>$$g_{k, j} = \min_{i=1}^k \lbrace b_j\times(k-pre_k) + f_{k, j - 1} \rbrace$$</p>
<h1 id="听课笔记"><a href="#听课笔记" class="headerlink" title="听课笔记"></a>听课笔记</h1>]]></content>
  </entry>
  <entry>
    <title>2020.10.15笔记</title>
    <url>/2020.10.15/</url>
    <content><![CDATA[<p>2020.10.15笔记</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>题目要求的限制反应在后缀树上即不能有祖先关系，而树上贪心选叶子结点一定是最优的，所以答案就是叶子结点的个数。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>打表找规律，爆搜可以打出来 $n \leq 16$ 的表。</p>
<p>首先 $k$ 的规律非常明显，不多赘述。</p>
<p>再观察方案是如何构造的：</p>
<ul>
<li>首先，$x, y$  一定取遍 $[1, k]$。</li>
<li>当 $n \equiv 2 \mod 3$ 时，$x$ 和 $y$ 的 $1$ 一定凑到一起。</li>
<li>剩下的数一定是依次和 $k, k-2, \dots$ 以及 $k-1, k-3 \dots$放在一起，直接写即可。</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>直接做非常棘手，考虑容斥原理。</p>
<p>但是限制依然非常多，无从下手。</p>
<p>这时需要注意到题目保证了 $a_i  &lt; a_{i+1}$，也就是说互不相同，再结合上面的观察，就可以发现其实限制是 $O(n)$ 级别的。</p>
<p>可以观察到一对相邻的位置如果有冲突，这两个数对 $k$ 取模的余数一定相同，且商相差 $1$。因此可以对这些数进行分类，分成若干个等差数列，容斥的时候考虑直接使得某些等差数列的某些长度大于 $1$ 的段放在一起即可，最后再乘上容斥系数和。需要注意的是长度大于 $1$ 的段有正反两种放法，单独的只有一种放法。</p>
<p>具体实现的时候可以讲所有等差数列首尾相接连在一起。</p>
<p>设 $f_{i, j 0/1}$ 表示考虑了前 $i$ 个间隔，已经违反了 $j$ 个限制，当前限制是否被违反，转移的时候直接枚举当前位置是否违反即可</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.13笔记</title>
    <url>/2020.10.13/</url>
    <content><![CDATA[<p>2020.10.13笔记</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>建一张新的无向图，把 $2n$ 条边对应成点，新图中的两个点有边当且仅当在原图中这两个点对应的两条边是相邻的。两条边相邻当且仅当具有一个公共端点。</p>
<p>可以发现问题相当于是对这张图进行二分图染色。</p>
<p>通过手玩等手段可以观察到每个连通块都一定只存在偶环，所以一定有解，答案就是 $2^{cnt}$，$cnt$ 为新图中连通块个数。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>这题相当于是把CSP2019的D1T3搬到了序列上然后变成计数。</p>
<p>对于每个位置 $i$，若 $a_i=i$则显然是无解的，因为相邻两个位置只会被交换一次，被换走是换不回来的。</p>
<p>接下来只需要考虑 $a_i&gt;i$ 和 $a_i &lt; i$ 的情况即可，因为这两种情况是对称的，所以这里只介绍 $a_i&lt;i$ 的情况。</p>
<p>设 $b_i$ 表示 交换 $i$和 $i+1$ 的时间。</p>
<p>如果 $a_i &lt; i$，将转化成对于操作序列的若干限制，形如 $b_i &lt; b_{i+1}$ 或者 $b_i &gt; b_{i+1}$ 这种形式。</p>
<p>方便起见，设 $p = a_i$</p>
<p>具体来说，有如下限制：</p>
<ul>
<li>$b_i &lt; b_{i+1}$</li>
<li>$b_{p-1} &lt; b_{p}$</li>
<li>对于 $j \in [p, i - 2], b_{j}&gt;b_{j+1}$</li>
</ul>
<p>第一个限制是说 $a_i$ 不能先被换走，因为目标是要移动到左边；</p>
<p>第二个限制是说 $a_i$ 移动到位置 $p$ 之后不能被换走；</p>
<p>第三个限制是要依次从右到左交换来保证 $i$ 位置的数到达 $p$。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>部分分 $n=2$ 可以发现是一定有解的，因为总可以构造一个方案使得都变成零。具体来说就是从左往右扫，先用列操作消掉左下角，然后对角线操作消掉左上角。</p>
<p>再说说正解。</p>
<p>有解当且仅当每个 $3 \times 3$ 的矩阵都满足如下条件：</p>
<p>$$a_{1, 1} +a_{2, 3} + a_{3, 2} = a_{1, 2} + a_{2, 1} + a_{3, 3}$$</p>
<p>这个等式移项之后相当于相加变成 $0$，且任何操作都不影响这个等式，而且可以根据这个等式可以发现：如果除右下角之外，剩余所有数都是 $0$，那么右下角也一定是 $0$。</p>
<p>那么就可以用类似 $n=2$ 的构造方案，先消掉前两行两列，如果此时有解那么剩下的树也已经都变成 $0$了，反之无解。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>套路题，$\mathscr{dp}$ 斜率优化。</p>
<p>设 $f_{l, r}$ 表示最后一段为 $[l+1, r]$ 时的最大价值。</p>
<p>这个端点的是 $[l + 1, r]$ 纯属是为了方便推式子和写代码，少很多加减和边界。</p>
<p>转移为：</p>
<p>$$f_{l, r} = \min_{k=0}^{l-1} \big{  f_{k, l} + (s_r - s_l) \times (s_l - s_k) \big } $$</p>
<p>其中 $s_i$ 表示的是 $\sum_{j=0}^ia_j$，也就是前缀和。</p>
<p>直接按照这个式子顺着枚举 $l, r, k$ 的时间复杂度是 $O(n^3)$ 的，考虑优化。</p>
<p>这个式子拆掉后面的乘号可以得到：</p>
<p>$$f_{l, r} = f_{k, l} + s_l(s_r - s_l) + s_l \times s_k - s_r \times s_k$$</p>
<p>$s_l(s_r - s_l)$ 和  $k$ 无关，可以提到取 $\min$ 外面，最后再加上。</p>
<p>$$f_{l, r} = f_{k, l} + s_l \times s_k - s_r \times s_k$$</p>
<p>移一下项可以得到</p>
<p>$$f_{l, r} + s_r \times s_k= f_{k, l} + s_l \times s_k $$</p>
<p>这就已经是斜率优化的形式了。</p>
<p>但是问题在于依次枚举的话，$s_k$ 和自变量 $s_r$ 都不是单调的，想要进行斜率优化只能使用 $CDQ$ 分治或者平衡树。</p>
<p>但是实际上是不必要的，这个转移其实是分层的，求 $f_{l, r}$ 的时候只会用到 $f_{k, l}$ 的值，这些数都是可以预先求出来的，而且 $s_i$ 也可以在一开始进行排序，所以其实斜率和自变量都是单调的。</p>
<p>本题求的是最大值，维护的是上凸壳，可以按照 $s_k$ 递增的顺序求出上凸壳，然后再按照 $s_r$ 递增的顺序求出 $f_{l, r}$，此时决策点是单调左移的，直接弹栈维护决策点即可。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.12笔记</title>
    <url>/2020.10.12/</url>
    <content><![CDATA[<p>2020.10.12笔记</p>
<a id="more"></a>


<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>依次从零开始枚举 $S$ 的所有前缀长度 $i$，然后考虑有多少形成的串是在上个前缀已经出现过的。</p>
<p>这一位的答案就是 $|T| +1 - cnt_{S_{i}}$，$cnt_i$ 表示 $i$ 这个字符在 $T$ 中出现了多少次。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>这个问题等价于 $n$ 个指数生成函数进行二项卷积之后 $m$ 次项的系数。</p>
<p>注意到 $m$ 非常小，$n$ 非常大，而且只关心前 $m+1$ 项的系数，因此可以将 $a_i &gt; m$ 的位置都设置成 $m$。发现只有 $m$ 种不同的多项式，求出循环节之后计算这 $m$ 种多项式分别有多少个，然后进行 $m$ 次多项式快速幂即可，使用暴力卷积每次快速幂的复杂度是 $O(m^2 \log n)$，总复杂度是 $O(m^3 \log n)$。</p>
<p>再给个正常的 $dp$ 的做法吧。</p>
<p>先考虑倍增合并所有 $a_i$ 相同的糖果，这些糖果彼此都是可以辨别的，因此只关心已经转移了多少种。</p>
<p>设 $g_{i, j}$ 表示已经考虑了前 $2^i$ 种，放了 $j$ 个糖，有倍增转移：</p>
<p>$$g_{i, j} = \sum_{k=0}^{j}{g_{i-1, k} \times g_{i - 1, j - k} \binom{j}{k}}$$</p>
<p>设 $f_{i, j}$ 表示只放 $a_k=i$ 糖，放了 $j$ 个的方案数。将 $cnt_i$ 二进制分解后做和求 $g$ 相同的转移即可。</p>
<p>最后再将所有的 $f_i$ 使用相同的转移合并即可。</p>
<p>这种做法和上面的多项式快速幂本质其实是完全一样的。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>求两个串的编辑距离是经典的动态规划问题，设 $g_{i, j}$ 表示使得 $S$ 的前 $i$ 位和 $T$ 的前 $j$ 位相同的最小代价，转移方程为：</p>
<p>$$g_{i, j} = \min \left{  g_{i-1, j}+1, g_{i, j-1}, g_{i - 1, j - 1} + [S_i \neq t_j] \right }$$</p>
<p>不难发现复杂度是 $O(|S||T|)$ 的，在本题中会面临 $|S|$ 串太长而导致复杂度爆炸的问题。</p>
<p>考虑另辟蹊径，使得 $T$ 变成 $S$ 的子序列，然后再通过若干插入操作使其相等。</p>
<p>设 $f_{i, j, k}$ 表示使得 $T$ 长度为 $i$ 的前缀，经过 $j$ 次删除和 $k$ 次修改之后，能变成的 $S$ 的最短的前缀的长度，满足 $T[1:i]$ 是该前缀的子序列。</p>
<p>不难发现这个 $dp$ 的状态数是 $|T||S|^2$的。</p>
<p>不过先不急，先来考虑如何求出答案。</p>
<p>通过 $f_{|T|, j, k}$可以得到以下代价的方案：</p>
<p>$$|S| - |T| + 2 \times j + k$$</p>
<p>仔细想想，其实即使把 $|T|$ 全删掉，再插入回去，代价也只是 $|S| + |T|$，所以 $2j + k \leq 2|T|$，因此后面两维只需要开到 $2|T|$ 即可。</p>
<p>进一步，可以把后面两维压成一维，把删除的代价改成 $2$ ，即可做到 $O(n|T|^2)$ 求出这个数组。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>对于字典序最小或者最大的题目，应该习惯性地想到<strong>诸位确定</strong>以及 <strong>二分答案</strong>。</p>
<p>对于本题也要用到诸位确定的思想。</p>
<p>依次枚举每一位 $p$， 类比数位 $dp$，若已经有位置小于限制，那以后就可以随便填，否则就不再有限制。</p>
<p>求出某个前缀确定之后的合法方案，即可确定这一位填什么，因此重点在于如何求出方案。</p>
<p>方案由三部分乘起来：分别是排列的方案，权值分配的方案，以及未确定的点是子树最小值的概率。</p>
<h3 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h3><p>先来考虑讲一个排列放在树上，使其满足堆性质的方案数：</p>
<p>首先每个点是子树内最小值的概率是 $1 \over size_i$，总方案数为 $n!$，然后结点是最小值之间是互相独立的，因此方案数就是 $\frac{n!}{\prod_{i=1}^nsize_i}$。</p>
<p>因此对于本题来说，<strong>满足是子树最小值的概率</strong>也就是未确定的点的 $size$ 乘起来再取倒数。</p>
<h3 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h3><p>注意到题目保证了 $fa_i &lt; i$，所以如果点 $i$ 被确定了，他的父亲也一定已经被确定了。（因为是按位考虑的）</p>
<p>可以想象一下，目前确定的一定是若干条和祖先相连的路径，没被确定的一定是若干个完整的子树，不会出现一个子树内夹着一个已经确定的点这种情况。</p>
<p>因为一定要满足小根堆的性质，所以每个点会对其子树进行一个约束，会要求其子树所有点的权值都要大于这个点的权值。不难发现最紧的约束一定是最深的结点带来的。</p>
<p>现在将造成约束最紧的点拿出来，这些点有两个属性，分别是 $s_i$ 表示 $i$ 子树内有多少点没有被确定，以及 $w_i$ 表示 $i$ 这个点的权值。</p>
<p>考虑给这些子树内的点分配权值。一个经典套路是先使用最紧的限制，也就是说要按照 $w_i$ 从大到小排序。</p>
<p><strong>权值分配</strong>方案为：</p>
<p>$$\prod_{i=1}^{k}{\binom{n-w_i-(i-1) - \sum_{j=1}^{i-1}s_i}{s_i}}$$</p>
<h3 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h3><p><strong>排列的方案</strong>可能是最为简单的一部分，就是对于每个限制最紧的点，计算 $\prod s_i!$。</p>
<p>上述思路可以带来一个 $O(n^3)$ 的做法，但是可以注意当前缀长度确定的时候，上述三部分只有权值分配的方案会变化。</p>
<p>变化是由于 $w$ 排名的变化产生的，如果从小到大枚举第 $k$ 位的值，可以发现每次只会影响相邻两位，且对于前缀和的影响也是可以直接计算的，所以精细地维护当前所在的位置，每次排名变化的时候交换位置再计算方案的偏移量即可做到 $O(n^2)$ 的复杂度。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.2 笔记</title>
    <url>/2020.10.2/</url>
    <content><![CDATA[<p>2020.10.2 笔记</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>二分答案，然后变成类似线段覆盖特殊点的问题，贪心即可。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>可以发现总移动的段数是 $n \log n$的。</p>
<p>考虑对暴力移动进行优化。</p>
<p>可以发现每次移动相当于是先交换所有段的开头，然后整体向右移动一格。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>暴力求中点$dp$即可，优化的话可以考虑使用中点的单调性，先 $n^2$ 预处理中点。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>类比某年的NOIP题目联合权值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    fa[u] = pre;</span><br><span class="line">    <span class="keyword">int</span> k = fa[fa[u]];</span><br><span class="line">    <span class="keyword">if</span> (k) ss[k] += a[u];</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>, ssum = <span class="number">0</span>, stwo = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//one：前缀长度为 2 的链的端点取值和</span></span><br><span class="line">    <span class="comment">//two：前缀任何两个长度为 2 的链的端点的乘积的和</span></span><br><span class="line">    <span class="comment">//ssum：a[v]的前缀和</span></span><br><span class="line">    <span class="comment">//stwo:前缀的儿子中，每个儿子长度为2的链的和的前缀和</span></span><br><span class="line">    PE(e, u) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        ss[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pp = dfs(v, u);</span><br><span class="line">        ans += a[v] * stwo + pp * ssum;</span><br><span class="line"></span><br><span class="line">        ans += two * ss[u];</span><br><span class="line"></span><br><span class="line">        two += one * ss[u];</span><br><span class="line">        one += ss[u];</span><br><span class="line"></span><br><span class="line">        stwo += pp;</span><br><span class="line">        ssum += a[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k) ans += a[k] * two;</span><br><span class="line">    <span class="keyword">return</span> two;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="BZOJ1426"><a href="#BZOJ1426" class="headerlink" title="BZOJ1426"></a>BZOJ1426</h2><p>设 $f_{i}$ 表示已经有了 $i$ 种，期望还需要买的次数。    </p>
<p>$$f_i =1 + \frac{i}{n}f_i+\frac{n-i}{n}f_{i+1}$$</p>
<p>整理得：</p>
<p>$$f_i = f_{i+1} + {n \over n - i}$$</p>
<p>设 $g_i$表示有了 $i$ 种，期望还需要花费的钱数。</p>
<p>$$g_i = 1+ {i \over n}(g_i+f_i) + {n - i \over n}(g_{i+1} + f_{i+1})$$</p>
<p>这个式子可以看做当成一开始买代价为 $1$，然后加上期望买的次数相当于补上了每次贵一块钱。</p>
<p>化简得</p>
<p>$$g_i = {n \over n - i} + \frac{i}{n-i}f_i + g_{i+1} + f_{i+1}$$。</p>
<h2 id="BZOJ-3823"><a href="#BZOJ-3823" class="headerlink" title="BZOJ 3823"></a>BZOJ 3823</h2><p>考虑把 $n$ 维立方体抽象成一个 $n$ 维的 $01$ 向量。</p>
<p>那么 $k$ 维元素是一个 $k$ 维向量，且起始位置有 $2^{n-k}$ 个。</p>
<p>所以 $k$ 维元素共有 $\binom{n}{2}2^{n-i}$个。</p>
<p>本题需要注意 $n \geq p$ 的情况，需要把每个数写成 $p^a*b$ 的形式。</p>
<h2 id="小左的GCD"><a href="#小左的GCD" class="headerlink" title="小左的GCD"></a>小左的GCD</h2><p>求 $\sum_{i=1}^{n}{\sum_{j=1}^{n}[\gcd(i, j)\ is\ prime]}$。</p>
<p>首先枚举素数 $i$，然后相当于求 $\lfloor \frac{n}{i} \rfloor$ 以内互质的数对个数。<br>即为<br>$$2 \times\sum_{i=1}^{\lfloor \frac{n}{i} \rfloor} \varphi_i - 1$$</p>
<h2 id="幸运数字"><a href="#幸运数字" class="headerlink" title="幸运数字"></a>幸运数字</h2><p>求最少的连续的 $8$ 组成的数字，使其是 $L$ 的倍数， $L \leq 2* 10 ^9$。</p>
<p>$8$ 组成的数字可以写成 $\frac{10^n-1}{9} \times 8$ 的形式。</p>
<p>也就是说要满足：</p>
<p>$$\frac{(10^{n}-1) \times 8}{9} \mid L$$</p>
<p>两边同时除以 $T = \gcd(8, L)$，再把 $9$乘过去。</p>
<p>$$8 \times \frac{10^{n}-1}{T} \mid \frac{9L}{T}$$</p>
<p>因为 $\gcd(\frac8T, \frac{9L}{T}) = 1$，所以只要满足</p>
<p>$$10^n - 1 \mid \frac{9L}{T}$$</p>
<p>相当于求最小的 $n$，满足：</p>
<p>$$10^n \equiv 1 \mod \frac{9L}{T}$$</p>
<p>这个问题就是求 $10$ 在 $\bmod \frac{9L}{T}$ 意义下的阶，枚举 $\varphi_{\frac{9L}{T}}$ 的因子，暴力判断即可，复杂度为 $O(\sqrt{L})$。</p>
<h2 id="不知道叫啥"><a href="#不知道叫啥" class="headerlink" title="不知道叫啥"></a>不知道叫啥</h2><p>给定一个长度为 $n$ 的排列$P$，$Q$次询问区间$[l, r]$内满足有倍数关系的($P_i , P_j)$有多少对。</p>
<p>$n \leq 10^5, Q \leq 10^5$。</p>
<p>合法的对数是 $n \log n$级别的，所以是个二维数点问题。</p>
<h2 id="还是不知道叫啥"><a href="#还是不知道叫啥" class="headerlink" title="还是不知道叫啥"></a>还是不知道叫啥</h2><p>考虑每一列只会有一个颜色没有出现，所以可以转化为一列元素，相邻元素不同的问题。</p>
<p>数量的限制可以通过解方程得到每个方案应该放的方案数。</p>
<p>考虑先把第一种放下去，然后枚举第二种分了多少段，组合数求出位置的方案数，然后用第三种求填不合法的位置，需要讨论开头结尾放不放。                      </p>
<p>$$T(n)=aT(n/b)+O(n^{log_b a}log^kn)$$<br>$$T(n)=O(n^{log_b a}log^{k+1}n)$$</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.3笔记</title>
    <url>/2020.10.3/</url>
    <content><![CDATA[<p>2020.10.3笔记</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>两边直接取对数即可。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>大模拟，读入写就完事了。</p>
<p>读入之外的部分是个类似于拓扑排序的东西，不过需要用两个平衡树维护。一个记录当前所有正在进行的任务，一个记录当前可以开始的任务。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>设多项式 $F(x)$ 的 $i$ 次项系数 $a_i$ 表示有 $a_i$ 个出现了 $i$ 次的数。</p>
<p>首先考虑质数的情况，质数的情况相当于直接进行多项式卷积。</p>
<p>如果不是质数就意味着是不互质的，考虑如何合并两个不互质的串。</p>
<p>记 $G = \gcd(len_a, len_b)$。</p>
<p>那么就相当于将 $a$ 分为 $\frac{len_a}{G}$ 个长度为 $G$ 的段，<br>将$b$ 分为 $\frac{len_b}{G}$ 个长度为 $G$ 的段。</p>
<p>不难发现 $\frac{len_a}{G}$ 和 $\frac{len_b}{G}$ 是互质的。</p>
<p>那么就相当于 $a$ 和 $b$ 都有 $G$ 个多项式，分别进行卷积。</p>
<p>然后直接这样做的复杂度是无法通过本题的，需要用到字符串长度都不超过 $50$ 的性质。</p>
<p>不超过 $50$ 意味着可以按照根号将合数进行分类。</p>
<p>一共有 $2, 3, 5, 7$ 这四个根号以内的质数。</p>
<p>一开始可以将所有因子只包含这些数的串手动拓展成长度 $32<em>27</em>25*49$ 的串。</p>
<p>剩余的质数最多只出现一次，所以这些质数长度手动乘上 $12$ 。</p>
<p>这样的话就只需要以 $12$ 为 $\gcd$ 求十二次卷积即可。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>套路题，考虑所有逆序对合法数对 $(l, i, r)$ 对于答案的贡献。</p>
<p>应该是 $l \times(n - r)$。</p>
<p>那么直接树状数组求逆序对，修改的时候直接加上$pos$或者 $n - pos$，对应位置前后的答案直接相乘。</p>
<h2 id="P101-T3"><a href="#P101-T3" class="headerlink" title="P101 T3"></a>P101 T3</h2><p>设 $f_{i}$ 表示考虑了前 $i$ 条线段，且第 $i$ 条线段一定被选的最大贡献。</p>
<h3 id="只能种一次"><a href="#只能种一次" class="headerlink" title="只能种一次"></a>只能种一次</h3><p>按照左端点升序排序。</p>
<p>此时每块地只会被种一次，所以是选出若干线段在不交的前提下的最大价值，所以开荒的代价也可以一并计算到线段价值里面。</p>
<p>$f_{i} = p_i+ \max_{r_j &lt; l_i}f_j$</p>
<p>相当于求前缀最小值，直接维护前缀最小值或者使用树状数组都可以。</p>
<h3 id="可以种多次"><a href="#可以种多次" class="headerlink" title="可以种多次"></a>可以种多次</h3><p>按照左端点升序排序。</p>
<p>设 $pre_i = \sum_{i=1}^ia_i$，即代价的前缀和。</p>
<p>需要讨论三种情况：</p>
<ul>
<li>对于 $r_j &lt; l_i$，和上一问一样，转移为 $f_{i}=pre_{r_i}-pre_{l_i-1} + \max_{r_j&lt;l_i}{f_j}$，需要维护区间最大值。</li>
<li>对于 $r_j &gt; r_i$，此时 $j$ 这条线段被完全包含，不需要付出开荒代价，可以直接白嫖，但是目前最大的右端点不在 $r_i$，所以是对 $r_j &gt; r_i$ 的位置进行区间加法。</li>
<li>对于 $l_i \leq r_j \leq r_i$，有 $f_i = p_i-pre_{r_i} + \max_{l_i \leq r_j \leq r_i}{f_{j}+pre_{r_j}}$。</li>
</ul>
<h2 id="P98-T3-开包"><a href="#P98-T3-开包" class="headerlink" title="P98 T3 开包"></a>P98 T3 开包</h2><p>设 $f_{i, s1, s2, s3, s4, T}$ 表示依次考虑了前 $i$ 个数字，四个位置分别填了 $s1, s2, s3, s4$ 个数，当前第 $i$ 个数字填的状态为 $T$ 的最小价值。</p>
<h2 id="P98-T3-足球"><a href="#P98-T3-足球" class="headerlink" title="P98 T3 足球"></a>P98 T3 足球</h2><p>首先按照价值升序排序，从小到大依次考虑。（若不排序会算重方案。）</p>
<p>可以发现这样价值一定是最大的，且不会数重方案。</p>
<p>设 $f_{s1, s2, s3, s4}$ 表示最大的价值，最小的花费以及方案，直接转移即可。</p>
<h2 id="Problem-10"><a href="#Problem-10" class="headerlink" title="Problem 10"></a>Problem 10</h2><p>设 $f_{i, j}$ 表示拿了 $i$ 个数，这些数都是 $j$ 的倍数时先手的胜负状态。</p>
<p>设 $cnt_i$ 表示 $i$ 的倍数的个数。</p>
<ul>
<li>可以考虑 $f_{i+1, k}$，其中 $k$ 是 $j$ 的因子。</li>
<li>若 $i &lt; cnt_j$，也可以考虑 $f_{i+1, j}$。</li>
</ul>
<p>使用博弈论惯用的转移即可。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.4笔记</title>
    <url>/2020.10.4/</url>
    <content><![CDATA[<p>2020.10.4笔记</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>二分答案之后 $\text{Tarjan}$ 进行判断是否可行。 </p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>发现两条连续的段答案很容易合并，因此直接倍增即可。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>设 $f_{i, j}$ 表示考虑完前 $i$ 个位置，最后一个位置填的颜色是 $j$ 的最小代价。</p>
<p>转移加上前缀和后缀最小值优化可以做到 $n^2$。</p>
<p>但是还有一次可以连续染相同颜色的机会，这个如果直接枚举位置和颜色就会变成 $n^3$。</p>
<p>设 $pre_{i, j}$ 表示前 $i$ 个位置，最后一个位置不填 $j$ 的最小代价。</p>
<p>类似地，同时也设一个 $suf_{i, j}$ 表示 $[i, n]$，第 $i$ 个位置不填 $j$ 的代价。</p>
<p>然后枚举连续端的颜色，再依次从大到小枚举右端点，问题就变成了维护区间最小值的问题了，而且单调移动，可以使用单调队列进行优化。</p>
<p>前后两部分复杂度是分开的，因此总的时间复杂度为 $O(n^2)$。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题意转化一下，相当于求一条经过所有好点且不经过任何坏点的哈密顿路。</p>
<p>众所周知这是个 $NP$ 问题，因此只能状压。</p>
<p>设 $f_{i, s}$ 表示以第 $i$ 个好串结尾，已经走过了状态为 $s$ 的好串的最小距离。</p>
<p>这里还需要预处理两两好串之间的最小距离，在 $\text{AC}$  自动机上跑最短路即可。</p>
<p>注意到这里的最短路边权很小，不需要使用堆优化的 $Dijkstra$，拆边或者开四个队列循环使用即可。</p>
<h2 id="听课笔记"><a href="#听课笔记" class="headerlink" title="听课笔记"></a>听课笔记</h2><h3 id="Floyd求最小环"><a href="#Floyd求最小环" class="headerlink" title="Floyd求最小环"></a>Floyd求最小环</h3><p><img src="https://i.loli.net/2020/10/11/DToxES2uw1PHvYk.png" alt="image.png"></p>
<p>当模板背下来吧，中间的第一次变量为 $i, j$ 的<strong>循环边界不可改动</strong>。</p>
<h3 id="最短路可行边"><a href="#最短路可行边" class="headerlink" title="最短路可行边"></a>最短路可行边</h3><p>从起点跑一遍最短路，再从终点跑一遍反图最短路。</p>
<p>一条边在最短路上，当且仅当 $dis(s, u)+w(u, v)+dis(v, t)=dis(s, t)$</p>
<h3 id="poj3660"><a href="#poj3660" class="headerlink" title="poj3660"></a>poj3660</h3><p>跑一遍 $Floyd$ 传递闭包，一个牛的排名可以决定，当且仅当所有点都能到达这个点或者能被这个点到达。</p>
<h3 id="bzoj1706"><a href="#bzoj1706" class="headerlink" title="bzoj1706"></a>bzoj1706</h3><p>使用类似矩阵乘法的方式对最短路进行转移。</p>
<p>初始的 $Floyd$ 矩阵每次和邻接矩阵相乘，都相当于进行一次转移。套上矩阵乘法快速幂即可。</p>
<p>需要注意此时的单位矩阵应该都设为 $\infty$。</p>
<h3 id="poj-3635"><a href="#poj-3635" class="headerlink" title="poj 3635"></a>poj 3635</h3><p>最短路多记一维油量即可。</p>
<h3 id="Tales-of-seafaring"><a href="#Tales-of-seafaring" class="headerlink" title="Tales of seafaring"></a>Tales of seafaring</h3><p>注意到**边权都是 $1$**。</p>
<p>因此只需要求出起点到所有点的长度分别是奇数和偶数的最短路即可。</p>
<h3 id="NOIP-2017-逛公园"><a href="#NOIP-2017-逛公园" class="headerlink" title="NOIP 2017 逛公园"></a>NOIP 2017 逛公园</h3><p>设 $f_{i, j}$ 表示走到 $i$，比 $dis(s, i)$ 长 $j$ 的方案数。实现时需要使用记忆化搜索或者在反图上拓扑排序。</p>
<p>需要特判转移过程中遇到的边权和为 $0$ 的环，如果存在则有无数组解。</p>
<h3 id="POJ1201"><a href="#POJ1201" class="headerlink" title="POJ1201"></a>POJ1201</h3><p>对每个前缀和变量建点。</p>
<p>对于一个区间的限制相当于是对于对应两个前缀和变量的限制，按照差分约束的套路连边即可。</p>
<p>需要注意的是一开始也有一些默认的限制，即 $pre_i \leq pre_{i+1}$和 $pre_{i}+1 \geq pre_{i+1}$。</p>
<h3 id="PA2014-Kuglarz"><a href="#PA2014-Kuglarz" class="headerlink" title="PA2014 Kuglarz"></a>PA2014 Kuglarz</h3><p>和上一题有类似的套路，同样是要对于前缀和变量进行建点。</p>
<p>一开始是知道 $pre_{0}$ 是偶数，所以只需要使得所有点都和 $0$ 连通即可。</p>
<p>显然是一颗最小生成树。</p>
<h3 id="NOIP-2015-运输计划"><a href="#NOIP-2015-运输计划" class="headerlink" title="NOIP 2015 运输计划"></a>NOIP 2015 运输计划</h3><p>老题新做，二分答案 + 差分的做法就不再多提了。</p>
<h3 id="新做法1"><a href="#新做法1" class="headerlink" title="新做法1"></a>新做法1</h3><p>不二分了，发现改掉的边在排序后的一段最大的前追上是最优的。</p>
<p>因此可以枚举改掉的边在前 $k$ 大边的公共路径上，相当于要维护路径交和路径最大值，这个都是可以通过倍增实现的，然后使用 $\max \lbrace len_1-max_k, len_{k+1} \rbrace$更新答案即可。</p>
<h3 id="新做法2"><a href="#新做法2" class="headerlink" title="新做法2"></a>新做法2</h3><p>最终答案一定是要改最长路径的某条边，那么可以枚举最长路径上的这条边。</p>
<p>然后还会有若干不经过这条边的路径可能成为最大值，相当于求不经过某条边路径长度最大值。</p>
<p>具体求的时候需要用到这些边都在一条路径上的性质来简化算法。</p>
<h3 id="BZOJ3306"><a href="#BZOJ3306" class="headerlink" title="BZOJ3306"></a>BZOJ3306</h3><p>这题的亮点就在于这个换根操作。</p>
<p>假设当前的询问点是 $x$，当前的根是 $rt$，设 $t = LCA(x, rt)$。</p>
<p>分三种情况进行讨论：</p>
<ol>
<li>$x = rt$，相当于所有点都在查询范围内。</li>
<li>$t \neq x$，则还是查询初始 $x$ 的子树。</li>
<li>$t=x$，此时需要扣掉初始 $x$ 子树中 $rt$ 这条路径对应的子树，但仍是常数个区间，依然可以维护。</li>
</ol>
<h3 id="求拓扑图中每个点开始的路径条数"><a href="#求拓扑图中每个点开始的路径条数" class="headerlink" title="求拓扑图中每个点开始的路径条数"></a>求拓扑图中每个点开始的路径条数</h3><p>反着拓扑即可。</p>
<h3 id="求拓扑图中-S-到-T-必经边"><a href="#求拓扑图中-S-到-T-必经边" class="headerlink" title="求拓扑图中 S 到 T 必经边"></a>求拓扑图中 S 到 T 必经边</h3><p>求出 $f_i$ 表示 $s$ 到 $i$ 的路径条数，类似地可以定义 $g_i$ 表示从 $i$ 开始到 $t$ 的方案数。</p>
<p>一条边必经，当且仅当 $f_{u} \times f_{v} = f_t$。</p>
<h3 id="SDOI2009-Elaxia-的路线"><a href="#SDOI2009-Elaxia-的路线" class="headerlink" title="SDOI2009 Elaxia 的路线"></a>SDOI2009 Elaxia 的路线</h3><p>分别求出两个最短路图，然后求交，跑最长路即可。</p>
<h2 id="Dilworth-定理"><a href="#Dilworth-定理" class="headerlink" title="Dilworth 定理"></a>Dilworth 定理</h2><p><strong>拓扑图的最长反链等于最小链覆盖</strong></p>
<p>注意最长反链不是链，而是一个最大的点集，点集中的任意两个点都无法到达。</p>
<h3 id="NOIP1999-导弹拦截"><a href="#NOIP1999-导弹拦截" class="headerlink" title="NOIP1999 导弹拦截"></a>NOIP1999 导弹拦截</h3><p>第一问就是求最长不上升子序列。</p>
<p>第二问求的是原图里的最小链覆盖，根据 $Dilworth$ 定理转化成求最长反链，即 $\text{LDS}$。</p>
<h3 id="POJ1548"><a href="#POJ1548" class="headerlink" title="POJ1548"></a>POJ1548</h3><p>同样是求最小链覆盖，转化成求最长反链之后相当于求从左下角走都右上角的最长路。</p>
<h3 id="POI2014-Rally"><a href="#POI2014-Rally" class="headerlink" title="POI2014 Rally"></a>POI2014 Rally</h3><p>考虑按照拓扑序枚举删点。</p>
<p>把点集分为 $S$ 和 $T$，分别表示被删过的和没被删过的。</p>
<p>每次枚举到 $x$ 的时候，将所有左侧与 $x$相连的边都删掉，然后更新答案，再把 $x$ 加入左边，此时枚举 $x$ 的出边。</p>
<p>求答案的时候需要用一个堆维护路径长度的最大值。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.6笔记</title>
    <url>/2020.10.6/</url>
    <content><![CDATA[<p>2020.10.6笔记</p>
<a id="more"></a>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>尝试辗转相减之后，发现会跑到指数上去，因此直接对指数求 $\gcd$ 即可。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>用链表维护每个数的答案，删除的时候采用懒删除即可。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>拉格朗日恒等式：</p>
<p>$$\left(\sum_i a_i\right) \left( \sum_i b_i\right) = \left( \sum_i {a_i b_i}\right) ^2 + \sum_{i &lt; j} (a_ib_j - a_jb_i)^2$$</p>
<p>直接树状数组即可。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>读完题很让人摸不到头脑的一道题，但是实际上题意转化一下就是有若干变量，要满足某些大小的限制。</p>
<p>考虑到变量的值域非常大，但是一次性出现的值的数量很小，因此可以状压分层加入若干相等的变量，最后使用组合数计算方案。</p>
<p>注意不保证模数是质数，需要手写除法。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.5笔记</title>
    <url>/2020.10.5/</url>
    <content><![CDATA[<p>2020.10.1笔记</p>
<a id="more"></a>

<h2 id="PKU-2777"><a href="#PKU-2777" class="headerlink" title="PKU 2777"></a>PKU 2777</h2><p>颜色数量很小，相当于区间 $and\ xor$ 操作，查询区间 $or$。</p>
<h2 id="hdu2195"><a href="#hdu2195" class="headerlink" title="hdu2195"></a>hdu2195</h2><p>维护区间最小值，查询时根据最小值在线段树上二分，然后单点修改。</p>
<h2 id="PKU3667"><a href="#PKU3667" class="headerlink" title="PKU3667"></a>PKU3667</h2><p>查询要求求出最长空段，这个可以在线段树上维护最长空段，最长前后缀空段。区间清空直接打标记。</p>
<h2 id="动态连通块"><a href="#动态连通块" class="headerlink" title="动态连通块"></a>动态连通块</h2><p>线段树维护边角连通块的标号，合并区间的时候合并连通块。</p>
<h2 id="CF365D"><a href="#CF365D" class="headerlink" title="CF365D"></a>CF365D</h2><p>相当于求区间异或和，以及出现过的数的异或和。</p>
<p>前者直接前缀和，后者考虑离线维护。</p>
<p>用线段树维护每个左端点的答案，然后从左到右枚举右端点。</p>
<p>离线记录$nxt_i$ 表示第 $i$ 个位置上的数上一次出现的位置，每次相当于要修改 $[nxt_i-1, i]$ 的答案。</p>
<h2 id="CF396D"><a href="#CF396D" class="headerlink" title="CF396D"></a>CF396D</h2><p>考虑从做左往右枚举一个位置 $k$，使得前 $k- 1$ 位都是相同的，第 $k$ 为比 $p_i$ 要小。</p>
<p>现在考虑统计方案。</p>
<p>贡献分为三部分：</p>
<ul>
<li>第一部分来自前 $k-1$ 个元素内部，以及前 $k-1$ 个和后面的数之间的逆序对，这个可以用线段树维护。</li>
<li>第二部分是第 $k$ 位对后面的贡献。假设该位置可行的数字有 $u$ 个，那么贡献是 $\sum_{i=1}^u{(u-1)(n-k)!}$，可以提出来阶乘直接算。</li>
<li>第三部分是后面的数的贡献。长度为 $n$ 的全排列的逆序对总数为 $n!n(n-1)/4$。（可以从期望的角度考虑）。</li>
</ul>
<h2 id="CF392D"><a href="#CF392D" class="headerlink" title="CF392D"></a>CF392D</h2><p>非常有价值的一道题。</p>
<p>首先枚举第一个序列选到哪里，从后往前枚举。</p>
<p>此时会有若干个数字没在第一个序列出现过，那么对于这些数分别求一个数对 $(x, y)$，分别表示该数在第二个和第三个序列第一次出现的位置。</p>
<p>把这些数对抽象成二维平面上的点，每个点$(a, b)$带来的限制相当于是要么选择的 $x \geq a$ 或者 $y \geq b$。显然可以发现答案一定会取在点上，可以发现此时最优的点会组成一个阶梯。即随着 $x$ 的增大， $y$ 单调不增。</p>
<p>此时可以用两个 $set$ 分别维护阶梯和 $x+y$的值。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.9.27笔记</title>
    <url>/2020.9.27/</url>
    <content><![CDATA[<p>2020.9.27笔记</p>
<a id="more"></a>

<h2 id="ZROI-1567"><a href="#ZROI-1567" class="headerlink" title="ZROI 1567"></a>ZROI 1567</h2><p>题意就是判断变换 $k$ 次之后是不是欧拉图。</p>
<p><strong>无向欧拉图</strong>是<strong>连通</strong>且所有点<strong>度数都是偶数</strong>的图。</p>
<p>所以观察一下给定的对一张图的变换，可以发现原图的一条边 $i$ 变换一次之后对应的点度数取决于与 $i$ 相连的两个点的度数。</p>
<p>首先一定要满足的条件是连通，以下讨论均以连通作为前提。</p>
<p>图 $G$ 变换一次可以合法，当且仅当所有点的奇偶性相同。因为偶数=奇数+奇数或者偶数+偶数。</p>
<p>如果图中任意一条边的端点度数互异，那么变换一次会得到度数都是奇数的图，再变换一次就是欧拉图了。</p>
<p>但是这样还没完，一个连通块如果是链的话，每次变换点数和边数都会少一，需要特判。</p>
<h2 id="ZROI-1567-1"><a href="#ZROI-1567-1" class="headerlink" title="ZROI 1567"></a>ZROI 1567</h2><p>学习了一波矩形交的套路和整体二分。</p>
<p>整体来说是一道套路题。</p>
<p>看见第 $k$ 小，就应该条件反射想到二分答案。二分之后变成了求与某个矩形相交的矩形个数，如图，这个经过一波容斥之后就变成了二维数点问题。</p>
<p><img src="https://i.loli.net/2020/09/27/LblZenwkrPcmMCA.png" alt="HLGM8__7_SZ_TXT9U1767WL.png"></p>
<p>但是这东西每次二分再做复杂度不对劲。</p>
<p>其实可以套上一个整体二分。</p>
<p>总结一下就是整体二分+二维数点，复杂度为 $O((n+q) \log^2 n)$。</p>
<h2 id="bzoj4310-跳蚤"><a href="#bzoj4310-跳蚤" class="headerlink" title="bzoj4310 跳蚤"></a>bzoj4310 跳蚤</h2><p>题意：切最多 $k-1$ 刀，使得字典序最大的子串的字典序尽可能小。</p>
<p>二分答案，具体是哪个串可以算。</p>
<p>$$cnt = \sum_in-sa_i+1-height_i$$</p>
<p>检查的时候是个贪心。从后往前扫整个串，能不切就不切，不得不切的时候切一刀，具体切不切需要用到判断两个串的字典序大小，可以求 $LCP$ 之后讨论一下。</p>
<h2 id="K大数查询"><a href="#K大数查询" class="headerlink" title="K大数查询"></a>K大数查询</h2><p>整体二分练手题。</p>
<p>整体二分+区间加区间求和。</p>
<p>树状数组线段树皆可。</p>
<h2 id="Dynamic-Rankings"><a href="#Dynamic-Rankings" class="headerlink" title="Dynamic Rankings"></a>Dynamic Rankings</h2><p>带修区间第 $k$ 大。</p>
<p>修改看成一次删除和插入，一开始的序列也看成插入。</p>
<p>检查的时候相当于单点加，区间查询，树状数组即可。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.10.9笔记</title>
    <url>/2020.10.9/</url>
    <content><![CDATA[<p>2020.10.9笔记</p>
<a id="more"></a>

<h2 id="CF1025E"><a href="#CF1025E" class="headerlink" title="CF1025E"></a>CF1025E</h2><p>看似是模拟爆搜，实际是一个构造。</p>
<p>题目里非常关键的一个性质是 $m \leq n$。</p>
<p>读完题的第一想法应该是爆搜或者直接移动，但是很快就会发现问题在于会移动到已经涂了颜色的格子。问题的本质在于目的地会在重复的行或者列，且没有以合适的顺序进行移动。</p>
<p>下面给出一种从某个博客里看到的构造方法。</p>
<p>首先把所有起点和重点以 $x$ 为第一关键字， $y$ 为第二关键字进行升序排序。</p>
<p>排序之后所有点的横坐标是不降的。</p>
<p>现在要把排序后重新编号的每个点移动到 $(i, id_i)$，其中 $id_i$ 表示的是输入进来的顺序。</p>
<p>可以发现 $i$ 也是升序的，因此先移动 $x&gt;i$的点，再移动 $x&lt;i$的点，可以发现这样一定不会冲突，并且移动之后所有点的横坐标都不同了，此时可以直接移动纵坐标。</p>
<p>对起点和重点做完这个操作之后，可以发现对应起点和重点一定在同一列，直接移动即可。</p>
<h2 id="CF538H"><a href="#CF538H" class="headerlink" title="CF538H"></a>CF538H</h2><p>考虑如果没有 $t, T$ 的限制，选择哪两个点是最优的。</p>
<p>设 $n1 = \min r_i, n2 = \max l_i$。</p>
<p>这两个设置的变量还隐含着所有左端点都要小于等于 $n2$，右端点都要大于等于 $n1$。</p>
<p>若 $n1 \geq n2$，说明<strong>所有区间都有交</strong>，此时可以任意选取 $[n1, n2]$ 之间的所有点；<br>若 $n1 &lt; n1$ ，说明<strong>并不是所有区间都有交</strong>，此时最边缘的两个区间分别被 $n1, n2$ 覆盖，且 $n1$ 只能往左移动， $n2$ 只能往右移动，并且每一步移动都会使得限制变紧，因为集合 $A$ 需要满足 $l_i \leq n1$，集合 $B$ 需要满足 $r_i \geq n2$。</p>
<p>经过上述观察和思考，可以发现在考虑 $t, T$ 的贡献之后，可以发现第二种情况中，一定只会移动 $n1, n2$ 中的一个点来满足 $t, T$ 的限制。此时也可以看做这两种情况下的策略是相同的，具体实现的时候可以写在一起。</p>
<p>现在已经取出了最优的两个点 $n1, n2$， 再通过对每个连通块二分图染色即可判断是否合法。</p>
<p>具体实现的时候有个小技巧：先以只能分配到一个集合中的区间进行染色，剩下的连通块中所有点必然两个区间都可以选，可以随便染。</p>
<h2 id="CF1239B"><a href="#CF1239B" class="headerlink" title="CF1239B"></a>CF1239B</h2><p>这题最大的价值在于引入了一种非常直观有效的思考括号序列相关题目的工具：折线图。</p>
<p>对于一个长度为 $n$ 的括号序列，把左括号看做 $+1$，右括号看做 $-1$，求出该序列的前缀和数组 $h_i$。</p>
<p>一个括号序列合法的充要条件为：</p>
<ul>
<li>$\forall i \in [0, n], h_i \geq 0$；</li>
<li>$h_n = 0$。</li>
</ul>
<p>将 $h_i$ 画到平面直角坐标系中，可以发现合法的充要条件是：</p>
<ul>
<li>整条直线不低于 $x$ 轴。</li>
<li>$h_n=0$</li>
</ul>
<p>现在回到题目中，先来思考一个没有修改的 $Case$，即一个序列循环移位之后合法的括号序列有多少个。</p>
<p>若 $h_i=n$ ，结论是<strong>所有最小值所在的位置都一一对应一个合法的括号序列</strong>。</p>
<p>设所有最小值的位置为 $p_i$。可以发现原序列中 $p_i$ 的位置一定是右括号，且任意 $h_{p_i} \leq 0$。使得位置 $p_{i}+1$为新的序列的开头即可得到一个合法的括号序列。</p>
<p>至于为什么是合法的括号序列，则需要考虑该循环唯一对于前缀和数组的影响以及判定合法的充要条件。</p>
<p>设 $t = |\min h_i|$，可以发现操作之后，原来 $(p_i, n]$ 的位置整体上移 $y$ 个单位长度，且将 $[0, p_i]$ 这个折线也向上平移 $t$ 之后接到了后面。</p>
<p>现在思考一下这个折线图是否合法：</p>
<ul>
<li>整条折线向上平移了 $t$，可以发现一定不越过 $x$ 轴。</li>
<li>左右括号的数量并没有变化，所以 $h_n$依然为 $0$。</li>
</ul>
<p>至此简单的 $Case$ 已经解决了。</p>
<p>现在再考虑上进行一次修改，要使得最小值的数量最多。</p>
<p>一定只需要考虑交换不同的括号，否则这个操作相当于没做。</p>
<p>现在考虑交换对于 $h_i$ 数组的影响。</p>
<ul>
<li>交换<code>(</code>和<code>)</code> 相当于区间减 $2$。</li>
<li>交换<code>）</code>和<code>(</code>相当于区间加$2$。</li>
</ul>
<p>可以发现操作 $2$ 不会使得答案变优。</p>
<p>先将序列变成其中一个最小值对应的合法括号序列，这个操作一定是可以完成的，变换之后必然不会有区间是一段前缀和后缀拼起来，具体原因下面讲。</p>
<p>变换之后 $t=0$。</p>
<p>答案一定来自最小值是否变化两种情况。</p>
<ul>
<li>最小值不变，则需要最大化修改区间内 $2$ 的数量，且不能包含 $1, 0$。</li>
<li>最小值变化，则需要最大化 $1$ 的数量，且不包含 $0$。</li>
</ul>
<p>如果将原有的 $0$ 变成 $-2$ 显然是不优的，因为不会比原序列 $0$ 的数量更多。</p>
<p>至此问题解决，根据实现不同可以做到 $O(n)$  或者 $O(n \log n)$。</p>
<h2 id="CF1381D"><a href="#CF1381D" class="headerlink" title="CF1381D"></a>CF1381D</h2><p>设 $len = dis(a, b)$。</p>
<p>有解的必要条件为：</p>
<ul>
<li>存在一个特殊点，具有三条与其相连的长度大于等于 $len$ 的不交链。</li>
</ul>
<p>至于为什么不充分，是因为可能存在这条蛇被卡在两个叶子而动弹不得的情况。</p>
<p>所以需要首先判断是否存在特殊点，任取一个，以该点为根，使得$a,b$ 轮流向叶子移动，当 $a, b$ 其中一个是另一个的祖先时即可判断合法。</p>
<p>若移动 $n$ 次以上依然不合法，即为无解。</p>
<p>读完上述流程你想问为什么可以任选一个特殊点。</p>
<p>这是因为特殊点之间是彼此可达的，其中一个无解其他的也都会无解。</p>
<h2 id="NOI2020-制作菜品"><a href="#NOI2020-制作菜品" class="headerlink" title="NOI2020 制作菜品"></a>NOI2020 制作菜品</h2><h3 id="m-n-1"><a href="#m-n-1" class="headerlink" title="m = n -1"></a>m = n -1</h3><p>首先考虑 $m = n-1$ 的情况，此时一定有解。</p>
<p>先将 $d_i$ 升序排序，此时一定有：</p>
<ul>
<li><p>$d_1 &lt;k$</p>
</li>
<li><p>$d_1 + d_n \geq k$</p>
</li>
</ul>
<p>两者的证明方式都是考虑反证，然后使用不等式推出矛盾。</p>
<h3 id="m-geq-n"><a href="#m-geq-n" class="headerlink" title="$m \geq n$"></a>$m \geq n$</h3><p>此时一定有 $d_n \geq k$，证明和上面两个是一样的。</p>
<p>有这个条件之后，一定可以拿出一个数单独做一道菜，从而转化为 $m=n-1$的情况。</p>
<h3 id="m-n-2"><a href="#m-n-2" class="headerlink" title="$m = n - 2$"></a>$m = n - 2$</h3><p>这种情况下有解的充要条件是：可以选出一个集合 $S$，使得 $\sum_{i \in S} d_i = (|S|-1|)k$。</p>
<p>移项得到 $\sum_{i \in S} d_i - k = -k$。</p>
<p>跑一个 $01$背包即可得到 $85pts$，加上 $bitset$ 优化即可通过。</p>
]]></content>
  </entry>
  <entry>
    <title>2020.9.25笔记</title>
    <url>/2020.9.25/</url>
    <content><![CDATA[<p>2020.9.25笔记</p>
 <a id="more"></a>

<h2 id="CF1420D"><a href="#CF1420D" class="headerlink" title="CF1420D"></a>CF1420D</h2><p>计数问题，难点在于怎么不算重。</p>
<p>比赛的时候想过枚举连续的一段使其一定被所有选中的线段包含，然后容斥，但是复杂度不对，我也不会算容斥系数。</p>
<p>另一种思路是，从左往右枚举所有的点 $i$，统计所有包含 $i$，并且存在<strong>至少</strong>一条左端点为 $i$ 的选择方案。</p>
<p>原理简单来说就是每个方案只会在最靠左的都包含的位置统计到。</p>
<h2 id="CF1420E"><a href="#CF1420E" class="headerlink" title="CF1420E"></a>CF1420E</h2><p>考场读错题，看成了求最多有多少对没有盾牌位置被保护，实际上是求最多有多少对中间存在盾牌的没有盾牌的位置。</p>
<p>相当于是没有限制的方案数减去同一段内的方案数，那么最小化每一段的方案数和即可。</p>
<p>设 $f_{i, j, k}$ 表示考虑完前 $i$ 个位置，用了 $j$ 个盾牌，代价为 $k$ 时的最小方案数和。转移直接枚举下一个盾牌的位置，代价就是位置作差（不需要考虑跨越等情况，因为总存在一种合法的方案）。</p>
<h2 id="IOI2018-meetings"><a href="#IOI2018-meetings" class="headerlink" title="IOI2018 meetings"></a>IOI2018 meetings</h2><p>首先需要考虑复杂度为 $O(n^2)$ 的暴力动态规划。</p>
<p>设 $f_{l, r}$表示询问 $[l, r]$ 的答案。</p>
<p>转移的时候，需要观察到区间里的最大值作为关键点一定是不优的。所以有转移方程：</p>
<p>$$f_{l, r} = \min \lbrace f_{l, p -1} + a_p \times  (r - p + 1) , f_{p + 1, r} + a_p \times (p - l + 1) \rbrace$$</p>
<p>$p$ 为区间最大值所在的位置。含义就是关键点放在 $p$ 两边取个最优。</p>
<p>进一步优化需要使用到笛卡尔树。因为转移需要用到最值的位置。</p>
<p>先手动把一个询问拆成两半，相当于求 $f_{l, p - 1}, f_{p + 1, r}$，然后可以直接合并起来得到答案。同时 $p-1, p+1$ 一定是笛卡尔树上的端点，所以可以把询问都离线下来挂到笛卡尔树的结点上。</p>
<p>那么问题就变成了对于笛卡尔树上的一个结点 $[l, r]$，求 $f_{l, i}, i \in [l, r]$。</p>
<p>我们可以分治解决这个子问题，先求出两个儿子的信息。</p>
<p>也就是已知 $f_{l, i}, i \in [l, p - 1]$ 和 $f_{p + 1, i}, i \in [p + 1, r]$ 。</p>
<p>再观察一下上面给出的转移方程，左边一项相当于区间对一次函数取最小值，右边相当于直接区间加，考虑用线段树维护，但是问题在于直接维护复杂度是线性的。</p>
<p>那么现在再观察一下性质，$f_{p+1, r}$ 的每移动一位，增量一定不超过 $a_p$，因为 $a_p$ 是区间最大值。所以当右边一项更优的时候，往右走一定都是更优的，那么就可以用线段树维护了，在线段树上二分即可。</p>
<p>再来总结一下：</p>
<p>离线询问，挂到每个笛卡尔树的区间上，用线段树维护区间信息，需要支持<strong>区间加</strong>，<strong>区间对一次函数取最小值</strong>，单点查询。时间复杂度为 $O((n+q)\log n)$。</p>
]]></content>
  </entry>
  <entry>
    <title>【AHOI2017/HNOI2017】礼物</title>
    <url>/AHOI2017gift/</url>
    <content><![CDATA[<h3 id="题目链接-【AHOI2017-HNOI2017】礼物"><a href="#题目链接-【AHOI2017-HNOI2017】礼物" class="headerlink" title="题目链接 【AHOI2017/HNOI2017】礼物"></a>题目链接 <a href="https://www.luogu.org/problemnew/show/P3723">【AHOI2017/HNOI2017】礼物</a></h3><a id="more"></a>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>其实修改亮度可以看做对其中一串手环整体加或者整体减去 $c$ ，所以只要在括号里加上 $c$ 就可以了。原来的式子就变长了这样：</p>
<p>$$\sum_{i=1}^n(x_i-y_i +c)^2$$ </p>
<p>我们继续拆一下式子</p>
<p>$$\sum_{i=1}^n(x_i^2+y_i^2+c^2+2<em>c</em>x_i-2<em>c</em>y_i-2x_iy_i)$$ </p>
<p>$$\sum_{i=1}^n(x_i^2+y_i^2)+nc^2+2*c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i$$ </p>
<p>然后你会惊奇地发现，枚举了 $c$ 之后，除了最后一项之外都是常量。同时又是以最小化这个式子的值为目标的，所以只需要最大化$\sum_{i=1}^nx_iy_i$就可以了。</p>
<p>现在把 $y_i$ 翻转，那么原来的式子就变成了这样</p>
<p>$$\sum_{i=1}^{n}x_iy_{n-i+1}$$ </p>
<p>那你再把下标往左整体平移一下，</p>
<p>$$\sum_{i=0}^{n-1}x_iy_{n-i}$$ </p>
<p>这不是卷积吗？那我们只需要做一遍 $FFT$ 再错位处理一下，取一个最大值就可以了。</p>
<p>思考下 $FFT$ 的本质，画一张图，就能理解如何错位了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">std</span>::<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span><span class="comment">//自定义负数类</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * a.x - y * a.y, x * a.y + y * a.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum1, sum2;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>, e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAXN], v[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex *p, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">std</span>::swap(p[i], p[r[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; len; l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">root</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">cos</span>(PI / l), type * <span class="built_in">std</span>::<span class="built_in">sin</span>(PI / l))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += (l &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">t</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++, t = t * root) &#123;</span><br><span class="line">                Complex x = p[i + j], y = t * p[i + l + j];</span><br><span class="line">                p[i + j] = x + y;</span><br><span class="line">                p[i + l + j] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); n--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;b[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum1 += a[i].x * a[i].x + b[i].x * b[i].x;</span><br><span class="line">        sum2 += a[i].x - b[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n2 = n + n;</span><br><span class="line">    <span class="built_in">std</span>::reverse(b, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n2) len &lt;&lt;= <span class="number">1</span>, e++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (e - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    fft(a, <span class="number">1</span>), fft(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        a[i] = a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fft(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n2; i++) &#123;</span><br><span class="line">        v[i] = (<span class="keyword">int</span>)(a[i].x / len + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> val = v[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//错位处理</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; v[i] + v[i + n + <span class="number">1</span>]) &#123;</span><br><span class="line">            val = v[i] + v[i + n + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = -m; i &lt;= m; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, sum2 * <span class="number">2</span> * i + (n + <span class="number">1</span>) * i * i - val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + sum1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.9.28笔记</title>
    <url>/2020.9.28/</url>
    <content><![CDATA[<p>2020.9.28笔记</p>
<a id="more"></a>

<h2 id="1416-A"><a href="#1416-A" class="headerlink" title="1416 A"></a>1416 A</h2><p>统计出所有权值的数字的最大间隔长度。可以发现一个权值的数字影响的是一个前缀的答案，所以倒着扫一遍更新一下即可。</p>
<h2 id="1416-B"><a href="#1416-B" class="headerlink" title="1416 B"></a>1416 B</h2><p>显然所有数要变成这个序列的平均数，因为每次操作相当于是把一些数字进行了移动，总量并没有发生变化。</p>
<p>在这个操作的限制下，所有位置可以减去自己的倍数。</p>
<p>观察到位置 $1$ 非常特殊，可以随意减去一个数，移动到另一个位置。</p>
<p>所以现在有一种思路是把所有数字都放到第一个位置，然后再分开。</p>
<p>现在的问题在于有一些位置没法全部移动到第一个位置，因为位置上的数字不能整除下标。同时在任意时刻不可以出现负数。</p>
<p>对于第一个问题，可以从第一个位置拿来一些凑成倍数。</p>
<p>现在的流程是：</p>
<ul>
<li>所有数都放到第一个位置，放不过去就从第一个位置先补几个。</li>
<li>从第一个位置分到所有位置。</li>
</ul>
<p>可以发现这个流程最多会操作 $3n - 3$ 次，现在只需要证明过程中不会出现负数就可以了。</p>
<p>对于第 $i$ 个位置，如果不能整除，那最多需要补 $i - 1$ ，同时现在前 $i-1$ 个数都放在第一个位置了，同时题目保证了一开始的序列都是正整数，所以必然不会出现负数。</p>
<h2 id="1416-C"><a href="#1416-C" class="headerlink" title="1416 C"></a>1416 C</h2><p>先来考虑如何比较两个二进制数的大小。（如果没对齐则高位补 $0$）</p>
<p>实际上就是比较两个数写成字符串的字典序。</p>
<p>字典序的比较就是找到两个数的最长公共前缀，这个最长前缀长度可以为 $0$，然后比较下一位的大小即可。</p>
<p>再考虑如何在每个二进制位处统计逆序对个数，这里的二进制位指的是最长前缀后的下一位。那么直接从前往后一次扫一遍，先在 $Trie$ 上查询一下每一位相反的位置，然后再插入即可。</p>
<p>顺序对的统计是同理的。</p>
<p>进一步观察一下，如果在两个数的公共前缀处翻转，其实并不影响两个数的大小关系。</p>
<p>所以根据每一位的顺序对和逆序对个数，按位贪心即可。</p>
<h2 id="1416-D"><a href="#1416-D" class="headerlink" title="1416 D"></a>1416 D</h2><p>套路感非常强的一道题。</p>
<p>首先查询相当于是问该点所在连通块的最大值，然后再做一次单点修改。</p>
<p>修改只有删边。</p>
<p>其实也就是说需要维护的是连通块的信息。一个图的连通性可以用并查集或者生成树等手段进行维护。</p>
<p>并查集肯定是没法支持这个的，倒着做改成加边也会无法维护信息。</p>
<p>所以考虑一下生成树。</p>
<p>一个很套路的做法是直接求删边时间的最大生成树。</p>
<p>这个想法其实很有道理，因为删非树边可以直接忽视掉，删树边就要尝试找一条边进行替代。</p>
<p>而如果使得树边是最后被删掉的，那就不需要找一条边进行替代了。</p>
<p>可以考虑直接用动态树维护最大生成树，查询连通块编号最大值和单点修改。</p>
<p>或者求出 $Kruscal$ 生成树，然后倍增跳到最浅的合法的点，线段树维护区间查询单点修改即可。</p>
<h2 id="1426-D"><a href="#1426-D" class="headerlink" title="1426 D"></a>1426 D</h2><p>很显然添加的数是正无穷一定不劣。那就都添加正无穷好了。</p>
<p>先对所有数求个前缀和，然后会有若干位置值相同，相同的值之间必须至少有个正无穷。</p>
<p>这个问题就相当于尽可能少的把序列切开，使得序列合法，贪心即可。</p>
<p>实现的时候需要特别注意边界。</p>
<h2 id="1426-E"><a href="#1426-E" class="headerlink" title="1426 E"></a>1426 E</h2><p>最大值非常简单，直接取最小值加起来就好了。</p>
<p>对于最小值<del>可以直接最大流</del>，其实可以暴力枚举三种操作的顺序，因为显然总存在一种连续的方案。</p>
<h2 id="1426-F"><a href="#1426-F" class="headerlink" title="1426 F"></a>1426 F</h2><p>设 $f_{i, j}$ 表示前 $i$ 个位置中，匹配了 $j$ 位的方案数。</p>
<p>转移根据该位的字符，添加一个即可。</p>
<p>需要注意的是如果是问号，则要枚举三种转移，并且继承的数组要乘以 $3$。</p>
]]></content>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/EXSegmentTree/</url>
    <content><![CDATA[<p>你需要写一种数据结构（可不参考题目标题），支持以下操作：</p>
<a id="more"></a>

<p>$\text{sum} ; l ; r$求区间 $[l,r]$ 的和。</p>
<p>$\text{max} ; l ; r$求区间 $[l,r]$ 的最大值。</p>
<p>$min ; l ; r ​$求区间$[l,r] ​$的最小值。</p>
<p>$add ; l ; r ; v$将区间 $[l,r]$ 内的所有数都加上 $v$ 。</p>
<p>$xor ; x ; v$将第 $x$ 个数按位异或 $v$ 。</p>
<p>$average ;l ; r$求区间 $[l,r]$ 内所有数的平均值（保留两位小数）。</p>
<p>$reverse ; l ; r$将区间 $[l,r]$ 内的所有数都变为原来的相反数。</p>
<p>$set l ; r ; v$将区间 $[l,r]$ 内的所有数都变成 $v$ 。</p>
<p>$square ; l ; r$求区间 $[l,r]$ 内所有数的平方和。</p>
<p>注意：对于操作 1 和 9，输出要对 $1000000007$ 取模。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll HA = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line">    ll sum, max, min, sqr, add, cov, mul;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> fsum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> newNode(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode(l, r, build(l, mid), build(mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        sum = (lc-&gt;sum + rc-&gt;sum) % HA;</span><br><span class="line">        max = <span class="built_in">std</span>::max(lc-&gt;max, rc-&gt;max);</span><br><span class="line">        min = <span class="built_in">std</span>::min(lc-&gt;min, rc-&gt;min);</span><br><span class="line">        sqr = (lc-&gt;sqr + rc-&gt;sqr) % HA;</span><br><span class="line">        fsum = lc-&gt;fsum + rc-&gt;fsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cov != LLONG_MIN) &#123;</span><br><span class="line">            lc-&gt;cover(cov), rc-&gt;cover(cov);</span><br><span class="line">            cov = LLONG_MIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (add  != <span class="number">0</span> || mul == <span class="number">-1</span>)&#123;</span><br><span class="line">            lc-&gt;multiply(mul), rc-&gt;multiply(mul);</span><br><span class="line">            mul = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            lc-&gt;plus(add), rc-&gt;plus(add);</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(ll c)</span> </span>&#123;</span><br><span class="line">        sum = ((c % HA) * (r - l + <span class="number">1</span>) % HA) % HA;</span><br><span class="line">        fsum = c * (r - l + <span class="number">1</span>);</span><br><span class="line">        max = c;</span><br><span class="line">        min = c;</span><br><span class="line">        sqr = ((c % HA) * ((c % HA) * (r - l + <span class="number">1</span>) % HA) % HA) % HA;</span><br><span class="line"></span><br><span class="line">        cov = c, add = <span class="number">0</span>, mul = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(ll m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        sum = -sum;</span><br><span class="line">        max = -max, min = -min, <span class="built_in">std</span>::swap(max, min);</span><br><span class="line">        fsum = -fsum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cov != LLONG_MIN) &#123;</span><br><span class="line">            cov *= <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add *= <span class="number">-1</span>;</span><br><span class="line">            mul *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">        max += a, min += a;</span><br><span class="line">        fsum += a * (r - l + <span class="number">1</span>);</span><br><span class="line">        a = (a % HA);</span><br><span class="line">        sqr = (sqr + <span class="number">2</span> * (a * sum) % HA + ((r - l + <span class="number">1</span>) * (a * a) % HA) % HA) % HA;</span><br><span class="line">        sum = (sum + ((r - l + <span class="number">1</span>) * (a % HA)) % HA) % HA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cov != LLONG_MIN) &#123;</span><br><span class="line">            cov += a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveAdd</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> plus(delta);</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;solveAdd(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;solveAdd(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;solveAdd(left, mid, delta), rc-&gt;solveAdd(mid + <span class="number">1</span>, right, delta);</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveMul</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right)  <span class="keyword">return</span> multiply(<span class="number">-1</span>);</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;solveMul(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;solveMul(left, right);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;solveMul(left, mid), rc-&gt;solveMul(mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveCov</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> cover(delta);</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;solveCov(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;solveCov(left, right, delta);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;solveCov(left, mid, delta), rc-&gt;solveCov(mid + <span class="number">1</span>, right, delta);</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> sum % HA;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;querySum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;querySum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (lc-&gt;querySum(left, mid) + rc-&gt;querySum(mid + <span class="number">1</span>, right)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> max;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;queryMax(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;queryMax(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">std</span>::max(lc-&gt;queryMax(left, mid), rc-&gt;queryMax(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> min;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;queryMin(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;queryMin(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">std</span>::min(lc-&gt;queryMin(left, mid), rc-&gt;queryMin(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">querySqr</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> sqr % HA;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;querySqr(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;querySqr(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (lc-&gt;querySqr(left, mid) + rc-&gt;querySqr(mid + <span class="number">1</span>, right)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">queryFsum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> fsum;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;queryFsum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;queryFsum(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lc-&gt;queryFsum(left, mid) + rc-&gt;queryFsum(mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *tree, poor[MAXN &lt;&lt; <span class="number">2</span>], *tail = poor;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;l = l, ret-&gt;r = r, ret-&gt;mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    ret-&gt;lc = lc, ret-&gt;rc = rc;</span><br><span class="line">    ret-&gt;sum = <span class="number">0</span>, ret-&gt;max = LLONG_MIN, ret-&gt;min = LLONG_MAX;</span><br><span class="line">    ret-&gt;sqr = <span class="number">0</span>, ret-&gt;add = <span class="number">0</span>, ret-&gt;cov = LLONG_MIN, ret-&gt;mul = <span class="number">1</span>;</span><br><span class="line">    ret-&gt;fsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    tree = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    ll value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;value);</span><br><span class="line">        tree-&gt;solveCov(i, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">    ll f, l, r, d;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;f, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (tree-&gt;querySum(l, r) + HA) % HA);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tree-&gt;queryMax(l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tree-&gt;queryMin(l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            tree-&gt;solveAdd(l, r, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">5</span>) &#123;</span><br><span class="line">            ll arch = tree-&gt;queryMax(l, l);</span><br><span class="line">            arch = arch ^ r;</span><br><span class="line">            tree-&gt;solveCov(l, l, arch);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, (<span class="keyword">double</span>)(tree-&gt;queryFsum(l, r)) / (<span class="keyword">double</span>)(r - l + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">7</span>) &#123;</span><br><span class="line">            tree-&gt;solveMul(l, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            tree-&gt;solveCov(l, r, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (tree-&gt;querySqr(l, r) + HA) % HA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【JZOJ5394】</title>
    <url>/JZOJ5394/</url>
    <content><![CDATA[<p>【JZOI5394】</p>
<a id="more"></a>

<h2 id="JZOJ5394"><a href="#JZOJ5394" class="headerlink" title="JZOJ5394"></a>JZOJ5394</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先考虑如果<strong>不扑灭任何着火点时</strong>每个点什么时候被点燃。</p>
<p>设 $dis_{i, j}$ 表示 $i$ 号点到第 $k$ 个的距离，那么这个点被点燃的时间就是 $\min_{j=1}^k dis_{i, j}$，把这个时间记为 $time_i$。</p>
<p>那么整张图被点燃的时间就是 $\max_{i = 1} ^ ntime_i$，记为 $t$。</p>
<p>整张图的点燃时间不被推迟的充要条件是不存在一个点 $v$，所有的 $dis_{v,k} \leq t$ 的着火点 $k$ 都被删除。说白了就是对于每个点都至少保留一个 $dis_{v, k}  \leq t$ 的着火点。 </p>
<p>观察数据范围发现 $k  \leq 20$ ,所以考虑把所有的灭火情况状压，状态  $s$ 的第 $i$ 为 $0$ 表示扑灭， $1$ 表示保留。</p>
<p>对于每个点，我们再设一个状态 $a_i$，若第 $j$ 号着火点到 $i$ 的距离小于等于 $t$ ，那么 $a_i$ 的第 $j$ 位为 $1$，否则为 $0$。</p>
<p>对于一个合法的方案 $x$，需要满足以下条件：</p>
<p>$$\forall i\in V,  a_i \land x \neq 0$$</p>
<p>正难则反，考虑补集转化。</p>
<p>对于一个点 $i$，不合法的方案就是把 $a_i$ 按位取反后的所有子集。</p>
<p>合法的集合可以通过高维前缀和在 $O(2^k \times k)$ 内处理出来，$dis$ 只需要跑 $k$ 遍最短路即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP std::make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CL(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for (int i = (l); i &lt;= (r); ++ i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for (int i = (r); i &gt;= (l); -- i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(x, a) for (int x = head[a]; x;x = edge[x].next)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN =  <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll HA = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, w, next;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="keyword">int</span> n, m, k, a[MAXN];</span><br><span class="line">ll dis[<span class="number">22</span>][MAXN], max = INT_MIN;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> f[(<span class="number">1</span> &lt;&lt; <span class="number">22</span>) + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;v, w, head[u]&#125;; head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fp</span><span class="params">(ll a, ll b = HA - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    ll r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a % HA;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>, a = a * a % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s, ll dis[])</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) dis[i] = <span class="number">1e14</span>, vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;ll, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(MP(dis[s] = <span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top().se; q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        PE(e, u) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + edge[e].w) &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[e].w;</span><br><span class="line">                q.push(MP(-dis[v], v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, k - <span class="number">1</span>) rep(s, <span class="number">0</span>, lim) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i)) f[s ^ (<span class="number">1</span> &lt;&lt; i)] |= f[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;flame.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;flame.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    rep(i, <span class="number">1</span>, k) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w), add(u, v, w), add(v, u, w);</span><br><span class="line">    rep(j, <span class="number">1</span>, k) dij(a[j], dis[j]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll tmp = LLONG_MAX;</span><br><span class="line">        rep(j, <span class="number">1</span>, k) tmp = <span class="built_in">std</span>::min(tmp, dis[j][i]);</span><br><span class="line">        max = <span class="built_in">std</span>::max(tmp, max);</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt = fp(<span class="number">2</span>, k), inv = fp(fp(<span class="number">2</span>, k));</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[j][i] &lt;= max) tmp |= (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = (~tmp) &amp; ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>);</span><br><span class="line">        f[tmp] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FWT();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    rep(s, <span class="number">0</span>, lim) cnt -= f[s];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, cnt * inv % HA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>【JZOI5908】开荒</title>
    <url>/JZOJ5908/</url>
    <content><![CDATA[<p>【JZOJ5908】开荒</p>
<a id="more"></a>

<h2 id="JZOJ5908开荒"><a href="#JZOJ5908开荒" class="headerlink" title="JZOJ5908开荒"></a>JZOJ5908开荒</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于查询操作，就是求给定点集两两间的路径并的点权和。不难想到点集的路径并就是虚树，而且 $\sum k \leq10^5$ ，显然是可以使用虚树解决的。</p>
<p>建虚树的时候需要支持路径求和，并且还要支持单点修改，因此可以使用树剖维护路径信息。</p>
<p>需要注意的是直接算的话某些点权会被算重，多算的部分减掉就可以了，还有就是特判只有一个点的情况。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP std::make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CL(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for (int i = (l); i &lt;= (r); ++ i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for (int i = (r); i &gt;= (l); -- i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(x, a) for (int x = head[a]; x;x = edge[x].next)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="function">Node *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,Node*,Node*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, head[MAXN];</span><br><span class="line"><span class="keyword">int</span> val[MAXN], deep[MAXN], dfn[MAXN], top[MAXN], fa[MAXN], size[MAXN], son[MAXN], pos[MAXN], s[MAXN], t, seq[MAXN], tail;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; E[MAXN], G[MAXN], a;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    Node *lc, *rc;</span><br><span class="line">    ll sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        Node *ret;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ret = newNode(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ret-&gt;sum = val[pos[l]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            ret = newNode(l, r, build(l, mid), build(mid + <span class="number">1</span>, r));</span><br><span class="line">            ret-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123; sum = lc-&gt;sum + rc-&gt;sum; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, ll d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r &amp;&amp; r == p)  &#123; sum = d; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) lc-&gt;change(p, d);</span><br><span class="line">        <span class="keyword">else</span> rc-&gt;change(p, d);</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == left &amp;&amp; r == right) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) <span class="keyword">return</span> lc-&gt;query(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) <span class="keyword">return</span> rc-&gt;query(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lc-&gt;query(left, mid) + rc-&gt;query(mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *root, pool[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, Node *lc, Node *rc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Node *tail = pool;</span><br><span class="line">    Node *ret = ++tail;</span><br><span class="line">    ret-&gt;l = l, ret-&gt;r = r, ret-&gt;mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    ret-&gt;lc = lc, ret-&gt;rc = rc;</span><br><span class="line">    ret-&gt;sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    fa[u] = pre;</span><br><span class="line">    deep[u] = deep[pre] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; (<span class="keyword">int</span>)E[u].size(); e++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[u][e];</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        init(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timeStep = <span class="number">0</span>;</span><br><span class="line">    dfn[u] = ++timeStep;</span><br><span class="line">    pos[timeStep] = u;</span><br><span class="line">    top[u] = tip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (son[u]) split(son[u], tip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; (<span class="keyword">int</span>)E[u].size(); e++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[u][e];</span><br><span class="line">        <span class="keyword">if</span> (v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        split(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[u]] &lt; deep[top[v]]) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        ret = ret + root-&gt;query(dfn[top[u]], dfn[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] &gt; dfn[v]) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">    ret += root-&gt;query(dfn[u], dfn[v]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[u]] &lt; deep[top[v]]) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] &gt; dfn[v]) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        ans += query(u, v);</span><br><span class="line">        dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = G[u].size();</span><br><span class="line">    <span class="keyword">if</span> (u == G[<span class="number">0</span>][<span class="number">0</span>]) count = <span class="built_in">std</span>::max(<span class="number">0</span>, count - <span class="number">1</span>);</span><br><span class="line">    ans -= <span class="number">1l</span>l * count * val[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    a.pb(u);</span><br><span class="line">    <span class="keyword">int</span> g = get(u, s[t]);</span><br><span class="line">    <span class="keyword">if</span> (g == s[t]) s[++t] = u;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; deep[s[t - <span class="number">1</span>]] &gt;= deep[g]) G[s[t - <span class="number">1</span>]].pb(s[t]), t--;</span><br><span class="line">        <span class="keyword">if</span> (g != s[t]) G[g].pb(s[t]), s[t] = g, a.pb(g);</span><br><span class="line">        s[++t] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a.clear();</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    s[t = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    a.pb(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::sort(seq + <span class="number">1</span>, seq + tail + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, tail) insert(seq[i]);</span><br><span class="line">    rep(i, <span class="number">2</span>, t) G[s[i - <span class="number">1</span>]].pb(s[i]);</span><br><span class="line"></span><br><span class="line">    dfs(G[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a.size(); i++) G[a[i]].clear();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;kaihuang.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;kaihuang.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, val + i);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v), E[u].pb(v), E[v].pb(u);</span><br><span class="line"></span><br><span class="line">    init(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    split(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    root = Node::build(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)  &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            val[u] = v;</span><br><span class="line">            root-&gt;change(dfn[u], v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u) &amp;&amp; u) seq[++tail] = u;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val[seq[<span class="number">1</span>]]);</span><br><span class="line">            	<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            solve();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>【JZOJ6281】 串</title>
    <url>/JZOJ6281/</url>
    <content><![CDATA[<p>【JZOJ6281】串</p>
<a id="more"></a>

<h2 id="JZOJ6281-串"><a href="#JZOJ6281-串" class="headerlink" title="JZOJ6281 串"></a>JZOJ6281 串</h2><p>一道让我想破头也想不出来的神仙DP（在省常中考过一遍再考我还是不会= =）。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果直接把答案当做要DP的东西，状态就会变得很不优。</p>
<p>先考虑对别的东西进行DP。</p>
<p>考虑删除 $\text{A}$ 串只能删除其中的 $\text{B}$ 串，这个限制很麻烦。</p>
<p>设 $f_{l, r}$ 表示删除 $[l, r]$ 的最小代价。</p>
<p>一个很显然的事情是，从 $\text{A}$ 串中删除 $\text{B}$ 串时，这些 $B$ 串只有包含和相离的关系，不可能相交（一个子串被删除一次就没了，怎么可能相交然后被删除两次）。</p>
<p>如果可以求出 $f$，就可以通过一个简单DP来解决这道题了。设 $h_{i, j}$ 表示A串的前 $i$ 位，删除 $j$ 次之后的最小长度。</p>
<p>这个简单DP的转移很显然：</p>
<ol>
<li>不删除的话，$h_{i, j} = h_{i - 1, j} +1$；</li>
<li>删除的话，枚举删除的是哪个后缀 $[k, i]$，则有 $h_{i, j} = h_{k - 1, j - f_{k, i}}$。</li>
</ol>
<p>接下来考虑怎么求 $f$。</p>
<p>上文中提到了删除的子串不会相交，只会包含和相离。</p>
<p>那么删除的时候，如果删除的若干子串包含的话，那么一定是先删掉最里面的子串，然后两端拼起来，前缀和后缀又组成了某个 $\text{B}$ 串。</p>
<p>所以考虑设一个辅助 $DP$ 的数组 $g_{l, r, i, j}$ 表示把 $[l, r]$ 删成第 $i$ 个 $\text{B}$ 串的长度为 $j$ 的前缀的最小代价。</p>
<ol>
<li>如果 $A[r]= B[i][j]$， $g_{l, r, i, j}$ 就可以直接从 $g_{l, r - 1, i, j - 1}$ 转移过来。</li>
<li>无论如何，都可以枚举删除一段后缀，进行转移，即枚举一个 $k$，$g_{l, r, ,i, j}$可以从 $g{l, k - 1, i, j} + f_{k, r}$ 转移过来。</li>
</ol>
<p>那么 $f$ 的转移就很简单，直接从 $g_{l, r, i, len_i}$ 转移就可以了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP std::make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CL(a, b) memset(a, b, sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for (int i = (l); i &lt;= (r); ++ i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for (int i = (r); i &gt;= (l); -- i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PE(x, a) for (int x = head[a]; x;x = edge[x].next)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, ans;</span><br><span class="line"><span class="keyword">char</span> a[MAXN], b[<span class="number">37</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN], g[MAXN][MAXN][<span class="number">37</span>][<span class="number">37</span>], lb[<span class="number">37</span>], h[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; y) x = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">&quot;string.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;string.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	CL(f, <span class="number">0x3f</span>); CL(g, <span class="number">0x3f</span>); CL(h, <span class="number">0x3f</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">	rep(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, b[i] + <span class="number">1</span>), lb[i] = <span class="built_in">strlen</span>(b[i] + <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	rep(len, <span class="number">1</span>, n) &#123;</span><br><span class="line">		rep(l, <span class="number">1</span>, n - len + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">			rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">				rep(j, <span class="number">1</span>, lb[i]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a[r] == b[i][j]) cmin(g[l][r][i][j],(l == r &amp;&amp; j == <span class="number">1</span>) ? <span class="number">0</span> : g[l][r - <span class="number">1</span>][i][j - <span class="number">1</span>]);</span><br><span class="line">					rep(k, l, r) cmin(g[l][r][i][j], g[l][k - <span class="number">1</span>][i][j] + f[k][r]);</span><br><span class="line">				&#125;</span><br><span class="line">				cmin(f[l][r], g[l][r][i][lb[i]] + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ans = n;</span><br><span class="line">	</span><br><span class="line">	rep(i, <span class="number">0</span>, n) h[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		h[i][<span class="number">0</span>] = h[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">		rep(j, <span class="number">1</span>, <span class="built_in">std</span>::min(i, k)) &#123;</span><br><span class="line">			h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">			rep(l, <span class="number">1</span>, i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (f[l][i] &lt;= j) cmin(h[i][j], h[l - <span class="number">1</span>][j - f[l][i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	rep(i, <span class="number">1</span>, k) cmin(ans, h[n][i]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>【LYOI】20181101 Solution</title>
    <url>/November-First/</url>
    <content><![CDATA[<p>Solution for LYOI contest 【2018.11.1】</p>
<a id="more"></a>

<h2 id="王太阳做糖"><a href="#王太阳做糖" class="headerlink" title="王太阳做糖"></a>王太阳做糖</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们把字母对记为$(l, r)$。</p>
<p>我们对于任意一个字母$(l_0,r_0)$，和它交叉的字母对$(l,r)$一定符合以下两点：</p>
<p>$$l_0 &lt; l &lt; r_0$$</p>
<p>$$r &gt; r_0$$</p>
<p>就是说左端点和$(l_0,r_0)$重合，这样计算不会算重。</p>
<p>因为是相同的字母两两配对，所以对相同字母组成的线段，一定不相交，更不存在包含的情况。</p>
<p>所以对于每个字母，与$(l_0,r_0)$这样相交的字母对最多只有一个。</p>
<p>记$pre_{i,c}​$表示前i个字母中，字母 $\text{c}​$ 组成的字母对的左端点 $\text{l}​$ 最后出现的位置，$next_i​$表示第 $\text{i}​$ 个字母，若其为左端点，与其配对的右端点的位置。</p>
<p>这样对于每个字母对就可以求出与它相交的字母对数了。</p>
<p>时间复杂度$O(n)$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN][base], next[MAXN], pos[MAXN][base], cnt[base];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;cross.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;cross.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pos[++cnt[num]][num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">            pre[i][j] = pre[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[num] &amp; <span class="number">1</span>) pre[i][num] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; base; c++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= cnt[c]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">2</span> * i - <span class="number">1</span>, r = <span class="number">2</span> * i;</span><br><span class="line">            next[pos[l][c]] = pos[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; base; c++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">2</span> * i &lt;= cnt[c]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = pos[<span class="number">2</span> * i - <span class="number">1</span>][c], r = pos[<span class="number">2</span> * i][c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[r][j] &gt; l) &#123;</span><br><span class="line">                    ans += next[pre[r][j]] &gt; r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="王太阳要糖"><a href="#王太阳要糖" class="headerlink" title="王太阳要糖"></a>王太阳要糖</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题面很长，干货很少。</p>
<p>读完题不难发现，只需要维护这张图的连通性就可以了，这个可以使用并查集实现。</p>
<p>难点在于如何查询历史连通性（<del>当然是可持久化并查集了</del>）。</p>
<p>实际上不需要可持久化并查集。</p>
<p>并查集如果不路径压缩的话，实际上树，树高在随机情况为$\log_2 n$,每次合并操作实际上是合并两颗树，查询操作是查询根节点。那么我们想要查询了历史版本的话，只需要记录每条边是什么时候加入的，查询操作只能顺着合法的边往上跳。</p>
<p>但是经过构造的数据可以卡掉这种未经优化的并查集，树的形态可能会极不优美。</p>
<p>所以我们使用按秩合并，把树高小的合并到树高大的树上，这样每次合并操作最多会使得树高$+1$。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN], h[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">int</span> t, ans;</span><br><span class="line"><span class="keyword">char</span> opr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (f[x] &gt;= <span class="number">0</span> &amp;&amp; g[x] &lt;= t) x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    x = get(x, t), y = get(y, t);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (h[x] &gt; h[y]) <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">    f[x] = y, g[x] = t;</span><br><span class="line">    h[y] += (h[x] == h[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	freopen(<span class="string">&quot;history.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;history.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> t, x, y, z, v;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) h[i] = <span class="number">1</span>, f[i] = <span class="number">-1</span>;</span><br><span class="line">        t = c = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opr);</span><br><span class="line">            <span class="keyword">if</span> (*opr == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), c = c * ans + v, ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                x = (c * ans + x) % n;</span><br><span class="line">                y = (c * ans + y) % n;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (*opr == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    merge(x, y, ++t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;z);</span><br><span class="line">                    z = (c * ans + z) % n;</span><br><span class="line">                    ans = ((get(x, t) == get(y, t)) == (get(x, t - z) == get(y, t - z)));   </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ans ? <span class="string">&#x27;N&#x27;</span> : <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="王太阳爬树"><a href="#王太阳爬树" class="headerlink" title="王太阳爬树"></a>王太阳爬树</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>入门级树形DP。</p>
<p>设$f_i$表示对于标号为 $\text{i}$ 的节点，使其所有叶子节点与 $\text{i}$ 不连通的最小代价。</p>
<p>对于一个节点 $\text{u}$ ，我们枚举它的所有儿子 $\text{v}$，$\text{(u,v)}$的边权为 $\text{w}$。</p>
<p>$$f_u=f_u+\min {w,f_v}$$</p>
<p>代码也超级短，注意初始化叶子节点就好了。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, w, next;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt;</span><br><span class="line"></span><br><span class="line">ll f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[++cnt] = &#123;v, w, head[u]&#125;; head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        f[u] += <span class="built_in">std</span>::min(<span class="number">1l</span>l * edge[e].w, f[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) f[u] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w), add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[s]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>并查集</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>A+B Problem</title>
    <url>/L1001/</url>
    <content><![CDATA[<p>By<a href="http://blog.aor.sd.cn/2017/12/03/SegmentTree.html">吴雨航</a></p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left,right,sum,tag;</span><br><span class="line">    SegmentTree *lc,*rc;</span><br><span class="line">    SegmentTree(<span class="keyword">int</span> left,<span class="keyword">int</span> right,SegmentTree *lc,SegmentTree *rc) : left(left), right(right), lc(lc), rc(rc), sum(<span class="number">0</span>), tag(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> l == r ? <span class="keyword">new</span> SegmentTree(l,r,<span class="literal">NULL</span>,<span class="literal">NULL</span>) : <span class="keyword">new</span> SegmentTree(l,r,build(l,mid),build(mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">        sum += (right - left + <span class="number">1</span>) * delta;</span><br><span class="line">        tag += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag)&#123;</span><br><span class="line">            lc-&gt;cover(tag);</span><br><span class="line">            rc-&gt;cover(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; right || r &lt; left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= left &amp;&amp; r &gt;= right) cover(delta);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            lc-&gt;modify(l,r,delta);</span><br><span class="line">            rc-&gt;modify(l,r,delta);</span><br><span class="line">            sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; right || r &lt; left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= left &amp;&amp; r &gt;= right) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;query(l,r) + rc-&gt;query(l,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    SegmentTree *segt;</span><br><span class="line">    segt = SegmentTree::build(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        segt-&gt;modify(i,i,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; segt-&gt;query(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】线段树</title>
    <url>/SegmentTree/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线段树是一种二叉搜索树，用来维护区间内的符合区间加法的值，支持高效的查询与修改操作。每一次操作的时间复杂度是 $O(log_2N)$ </p>
<a id="more"></a>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>线段树把区间[l,r]分成了[l,mid]与[mid+1,r]两部分。线段树把区间[1,n]一直递归地划分下去，直到区间内只有一个点为止，也就是到达了叶子结点。线段树的每个节点都存储了这个序列的一段区间，从根节点开始按照刚才所叙述的划分方法一直划分到叶子结点。每个结点都存储着这个区间的信息，以优化查询的时间。</p>
<h2 id="Lazytag"><a href="#Lazytag" class="headerlink" title="Lazytag"></a>Lazytag</h2><p>按照这种方式存储序列可以很快地查询这段区间内维护的值，因为是二叉树，所以时间复杂度为 $log_2N$ 。但是如果进行区间修改的话要修改的值反而更多了，该如何解决呢？那就是Lazytag。</p>
<p>要进行区间修改时，只修改这个区间的节点代表的值，不修改它孩子节点的值，而是用一个标记记录下来，表示这个区间要整体修改一个值。当在有标记的节点进行查询与修改操作时，在把这个标记下推(也就是代码中的push_down函数)。这样就能避免不必要的区间修改。</p>
<h1 id="混合运算"><a href="#混合运算" class="headerlink" title="混合运算"></a>混合运算</h1><p>当一颗线段树同时要支持区间加法与区间乘法时，需要特别注意运算顺序。也就是在下推标记的时候，先进行乘法标记的下推，再进行加法标记的下推。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://www.luogu.org/problemnew/show/P3373">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">New</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span> , SegmentTree *, SegmentTree *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll sum, add, mul;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left == right ? New(left, right, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">            : New(left, right, build(left, mid), build(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum = (lc-&gt;sum + rc-&gt;sum) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mulCover</span><span class="params">(ll d)</span> </span>&#123;</span><br><span class="line">        sum = (sum * d) % p;</span><br><span class="line">        mul = (mul * d) % p;</span><br><span class="line">        add = (add * d) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCover</span><span class="params">(ll d)</span> </span>&#123;</span><br><span class="line">        add = (add + d) % p;</span><br><span class="line">        sum = (sum + d * (r - l + <span class="number">1</span>)) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lc-&gt;mulCover(mul); lc-&gt;addCover(add);</span><br><span class="line">        rc-&gt;mulCover(mul); rc-&gt;addCover(add);</span><br><span class="line">        mul = <span class="number">1</span>;</span><br><span class="line">        add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mulUpdate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; r || right &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= l &amp;&amp; right &gt;= r) mulCover(d);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            push_down();</span><br><span class="line">            lc-&gt;mulUpdate(left, right, d);</span><br><span class="line">            rc-&gt;mulUpdate(left, right, d);</span><br><span class="line">            push_up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUpdate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ll d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; r || right &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= l &amp;&amp; right &gt;= r) addCover(d);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            push_down();</span><br><span class="line">            lc-&gt;addUpdate(left, right, d);</span><br><span class="line">            rc-&gt;addUpdate(left, right, d);</span><br><span class="line">            push_up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; r || right &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= l &amp;&amp; right &gt;= r) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            push_down();</span><br><span class="line">            <span class="keyword">return</span> (lc-&gt;query(left, right) + rc-&gt;query(left, right)) % p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; *tree, poor[MAXN * <span class="number">4</span>], *tail = poor;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">New</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;sum = ret-&gt;add = <span class="number">0</span>;</span><br><span class="line">    ret-&gt;mul = <span class="number">1</span>;</span><br><span class="line">    ret-&gt;l = l; ret-&gt;r = r;</span><br><span class="line">    ret-&gt;lc = lc; ret-&gt;rc = rc;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    tree = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;now);</span><br><span class="line">        tree-&gt;addUpdate(i, i, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag, x, y, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;flag, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            tree-&gt;mulUpdate(x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            tree-&gt;addUpdate(x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tree-&gt;query(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模板</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Treap学习笔记</title>
    <url>/Treap/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> $\text{Treap}$ 是一种附加了堆性质的二叉搜索树( $\text{ Binary Search Tree }$ ，简称 $\text{BST}$ )，但是不同于堆的是， $\text{Treap}$ 不必是完全二叉树。 $\text{Treap}$ 也正是由此得名($\text{Treap = Tree + Heap}$)，其原理是利用随机性来使树平衡，是一种实现简单的平衡树，能够完成 $\text{BST}$ 的各项基本操作，各基本操作的期望时间复杂度为 $O(\log_2n)$ 。  </p>
<a id="more"></a>  

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于一颗 $\text{BST}$ ，如果其结点的插入顺序是无序的，那么它有极大的概率是平衡的，即使存在一些极端情况，但是极少发生。那么便可以利用随机性来使 $\text{BST}$ 平衡。对于每个结点，对其附加一个随机的数值，以这些随机的数值决定其优先级，使其符合堆的性质（大根堆或者小根堆）。  </p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>我们可以用旋转的方法来同时维护堆和二叉搜索树的性质。<br>二叉搜索树的节点的键值要大于等于其左儿子的键值，小于等于其右儿子的键值，其中序遍历是有序的。那么其形态显然不唯一，可以通过旋转改变其形态，同时能保持其性质和中序遍历不变。<br>旋转操作也可以改变结点与其子树的位置关系，那么也可以用来维护堆的性质。<br>对于 $Treap$ 旋转操作分为两种，左旋与右旋。对于 $v$ 来说，左旋是指将 $v$ 的右子树绕着 $v$ 点向左旋转，代替 $v$ 点的位置。那么这样会产生新的问题。如果 $v$ 的右子树有左子树，那么就会产生冲突。其实只需要让 $v$ 的右子树的左子树成为 $v$ 的右子树即可。<br>右旋与左旋的方向相反。<br>下面给出例子来便于理解，从左到右为右旋，反之为左旋。（图片取自<a href="http://blog.aor.sd.cn/2018/05/02/%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">Rain Air’s Blog</a>）<br><img src="http://p3o3ovvyn.bkt.clouddn.com/rotate.png" alt="旋转">  </p>
<p>旋转的代码如下  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//左旋</span></span><br><span class="line">    Node *tmp = v-&gt;right;</span><br><span class="line">    v-&gt;right = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();</span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//右旋</span></span><br><span class="line">    Node *tmp = v-&gt;left;</span><br><span class="line">    v-&gt;left = tmp-&gt;right;</span><br><span class="line">    tmp-&gt;right = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();</span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>在树中插入给定权值的点。<br>根据权值在满足二叉搜索树性质的适当叶子结点进行插入，如果插入使得堆的性质被破坏，则进行旋转。特别地，如果在插入的过程中检查到键值相同的已经在树上的节点，则直接使其的副本数量+1。（代码中副本的数量用 $num$ 表示）。<br>代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        v = newNode();</span><br><span class="line">        v-&gt;val = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;</span><br><span class="line">        v-&gt;num++;</span><br><span class="line">        v-&gt;pushUp();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;</span><br><span class="line">        insert(v-&gt;left, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;left-&gt;pri) &#123;</span><br><span class="line">            rightRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(v-&gt;right, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;right-&gt;pri) &#123;</span><br><span class="line">            leftRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除树中给点权值的点。  </p>
<ul>
<li>如果要删除的点为叶子结点，直接删除即可；  </li>
<li>如果不是叶子结点，旋转到叶子结点再执行删除；  </li>
<li>如果该点没有左子树或右子树，将该点删除，使其唯一的子树移动到该点即可。特别的是，如果该权值的点有多个，只需使其副本数量减少。  </li>
</ul>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            v-&gt;num--;</span><br><span class="line">            v-&gt;pushUp();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                v = v-&gt;right;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                v = v-&gt;left;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left-&gt;pri &gt; v-&gt;right-&gt;pri) &#123;</span><br><span class="line">                rightRotate(v);</span><br><span class="line">                remove(v-&gt;right, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                leftRotate(v);</span><br><span class="line">                remove(v-&gt;left, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;</span><br><span class="line">            remove(v-&gt;left, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(v-&gt;right, value);</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, pri;<span class="comment">//val为简直，pri为随机生成的数据，使其满足堆的性质</span></span><br><span class="line">    <span class="keyword">int</span> size, num;<span class="comment">//size表示以该点为根的子树的大仙，num表示该点的副本数</span></span><br><span class="line">    Node *left, *right;<span class="comment">//左右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;<span class="comment">//更新size</span></span><br><span class="line">        size = num;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            size += left-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            size += right-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; poor[MAXN], *tail = poor, *root;<span class="comment">//poor是根据数据范围而定的内存池，优化new的过程</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">newNode</span><span class="params">()</span> </span>&#123;<span class="comment">//用内存池取代new操作</span></span><br><span class="line">    Node *ret = ++tail;</span><br><span class="line">    ret-&gt;val = <span class="number">0</span>, ret-&gt;pri = rand();</span><br><span class="line">    ret-&gt;size = ret-&gt;num = <span class="number">1</span>;</span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//左旋，通过引用更改其祖先的信息</span></span><br><span class="line">    Node *tmp = v-&gt;right;</span><br><span class="line">    v-&gt;right = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();<span class="comment">//更新结点信息，非常重要，不要忘写</span></span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(Node *&amp;v)</span> </span>&#123;<span class="comment">//右旋</span></span><br><span class="line">    Node *tmp = v-&gt;left;</span><br><span class="line">    v-&gt;left = tmp-&gt;right;</span><br><span class="line">    tmp-&gt;right = v;</span><br><span class="line">    v-&gt;pushUp(), tmp-&gt;pushUp();</span><br><span class="line">    v = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;<span class="comment">//当前结点为空，直接插入</span></span><br><span class="line">        v = newNode();</span><br><span class="line">        v-&gt;val = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;<span class="comment">//value已经在树里了，直接更新副本数量和子树大小</span></span><br><span class="line">        v-&gt;num++;</span><br><span class="line">        v-&gt;pushUp();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;<span class="comment">//根据BST的性质决定走左子树还是右子树</span></span><br><span class="line">        insert(v-&gt;left, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;left-&gt;pri) &#123;<span class="comment">//如果不满足堆的性质就旋上来</span></span><br><span class="line">            rightRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(v-&gt;right, value);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;pri &lt; v-&gt;right-&gt;pri) &#123;</span><br><span class="line">            leftRotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp;v, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//空点直接结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val == value) &#123;<span class="comment">//当前点就是要删除的，接着进行分类讨论</span></span><br><span class="line">        <span class="keyword">if</span> (v-&gt;num &gt; <span class="number">1</span>) &#123;<span class="comment">//有多个副本，直接修改该点的信息</span></span><br><span class="line">            v-&gt;num--;</span><br><span class="line">            v-&gt;pushUp();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//没有副本，要删除该点</span></span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left == <span class="literal">NULL</span>) &#123;<span class="comment">//如果左右子树中有一个为空，则直接使另一颗取代v的位置</span></span><br><span class="line">                v = v-&gt;right;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                v = v-&gt;left;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v-&gt;left-&gt;pri &gt; v-&gt;right-&gt;pri) &#123;<span class="comment">//如果不为空则要旋转到叶子结点，此时根据左右子树的pri关系来决定旋转方向</span></span><br><span class="line">                rightRotate(v);</span><br><span class="line">                remove(v-&gt;right, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                leftRotate(v);</span><br><span class="line">                remove(v-&gt;left, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v-&gt;pushUp();<span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//当前点不是的值不是value,则向子树进行操作，</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;</span><br><span class="line">            remove(v-&gt;left, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(v-&gt;right, value);</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;pushUp();<span class="comment">//别忘了更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(Node *v, <span class="keyword">int</span> rank)</span> </span>&#123;<span class="comment">//根据给定的排名，求出对应排名的值</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;<span class="comment">//记录左子树的大小，即为比v小的值的数量</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = v-&gt;left-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rank &lt;= s) &#123;<span class="comment">//说明此时要找到排名为rank的点在左子树中</span></span><br><span class="line">        <span class="keyword">return</span> getValue(v-&gt;left, rank);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rank &lt;= s + v-&gt;num) &#123;<span class="comment">//v的排名即为rank，返回v的值</span></span><br><span class="line">        <span class="keyword">return</span> v-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getValue(v-&gt;right, rank - s - v-&gt;num);<span class="comment">//在右子树中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRank</span><span class="params">(Node *v, <span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//求给定值的排名</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = v-&gt;left-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; v-&gt;val) &#123;  <span class="comment">//利用BST的性质判断该往哪里走</span></span><br><span class="line">        <span class="keyword">return</span> getRank(v-&gt;left, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == v-&gt;val) &#123;<span class="comment">//v即为所求</span></span><br><span class="line">        <span class="keyword">return</span> s + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s + v-&gt;num + getRank(v-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPre</span><span class="params">(Node *v, <span class="keyword">int</span> value, <span class="keyword">int</span> &amp;pre)</span> </span>&#123;<span class="comment">//求值value的前驱</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;/特判</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val &lt; value) &#123;<span class="comment">//该点值比value小，可能为前驱</span></span><br><span class="line">        pre = v-&gt;val;</span><br><span class="line">        getPre(v-&gt;right, value, pre);<span class="comment">//使前驱尽可能大</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        getPre(v-&gt;left, value, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSucc</span><span class="params">(Node *v, <span class="keyword">int</span> value, <span class="keyword">int</span> &amp;succ)</span> </span>&#123;<span class="comment">//求值value的后继</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;val &gt; value) &#123;</span><br><span class="line">        succ = v-&gt;val;</span><br><span class="line">        getSucc(v-&gt;left, value, succ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        getSucc(v-&gt;right, value, succ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;<span class="comment">//读入优化</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = ret * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> n, ans;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        <span class="keyword">switch</span>(x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                insert(root, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                remove(root, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, getRank(root, y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, getValue(root, y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                getPre(root, y, ans);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                getSucc(root, y, ans);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>Treap</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】SPFA算法</title>
    <url>/SPFA/</url>
    <content><![CDATA[<p>SPFA算法是Bellman-Ford（蛤？你说你不知道Bellman-Ford算法？）算法的队列实现方法，采取动态逼近的方式来求得单源最短路，时间复杂度为O（ek）e为边数，k是所有点进队的平均次数。适用于不存在负权回路的稀疏图。</p>
<a id="more"></a>
<p>下面给出指针写法，题目参考洛谷<a href="https://www.luogu.org/problemnew/show/3371">【模板】单源最短路径</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span><span class="comment">//定义结构体，Node为节点，Edge为边</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Edge *firstEdge;</span><br><span class="line">    <span class="keyword">int</span> dist;<span class="comment">//距起点的最小距离</span></span><br><span class="line">    <span class="keyword">bool</span> inQueue;<span class="comment">//判断是否再队列中</span></span><br><span class="line">&#125;node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    Node *from,*to;<span class="comment">//起点与终点</span></span><br><span class="line">    <span class="keyword">int</span> w;<span class="comment">//边权</span></span><br><span class="line">    Edge *next;</span><br><span class="line">    Edge(Node *from,Node *to,<span class="keyword">int</span> w) : from(from),to(to),w(w),next(from -&gt; firstEdge) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s],&amp;node[t],w);<span class="comment">//把边加入结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        node[i].dist = INT_MAX;</span><br><span class="line">        node[i].inQueue = <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="comment">//初始化，使所有点到起点的距离为无穷大，所有点都不在队列中</span></span><br><span class="line">    <span class="built_in">queue</span> &lt;Node *&gt; q;<span class="comment">//通过队列来进行松弛操作，动态逼近，这里采用STL写法</span></span><br><span class="line">    q.push(&amp;node[s]);</span><br><span class="line">    node[s].inQueue = <span class="literal">true</span>;</span><br><span class="line">    node[s].dist = <span class="number">0</span>;<span class="comment">//把起点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;<span class="comment">//队列不能为空</span></span><br><span class="line">        Node *u = q.front();<span class="comment">//每次从队首处理</span></span><br><span class="line">        q.pop();</span><br><span class="line">        u -&gt; inQueue = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge *e = u -&gt; firstEdge;e;e = e -&gt; next)&#123;<span class="comment">//枚举所有与u相连的边，查找能够更新dist的点</span></span><br><span class="line">            Node *v = e -&gt; to;</span><br><span class="line">            <span class="keyword">if</span>(v -&gt; dist &gt; e -&gt; w + u -&gt; dist)&#123;</span><br><span class="line">                v -&gt; dist = e -&gt; w + u -&gt; dist;</span><br><span class="line">                <span class="keyword">if</span>(! v-&gt; inQueue)&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    v -&gt; inQueue = <span class="literal">true</span>;<span class="comment">//如果不在队列中，就使其入队</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">int</span> u,v,l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;           <span class="comment">//读入</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;u,&amp;v,&amp;l);</span><br><span class="line">        add(u,v,l);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node[i].dist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>【ZROJ1217】</title>
    <url>/ZR1217/</url>
    <content><![CDATA[<p>【ZROJ1217】</p>
<a id="more"></a>

<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>首先对于这 $n^4$ 个点对考虑他们贡献了多少次。</p>
<p>考虑行和列都需要在固定的一个取值范围内，然后再分别计数乘起来，所以可以看出来行和列实际上独立的，并且可以划分成 $O(1)$ 段一次函数的形式。</p>
<p>然后考虑如何去掉绝对值。<br>把这些位置都按照权值的大小排序，把答案拆成这种形式：</p>
<p>$$S = 2 \times (S_L +S_R)$$</p>
<p>其中乘以二是因为每个点对会算两次，$S_L$ 和 $S_R$ 分别表示去掉绝对值之后的正数的贡献， $S_R$ 是类似的。<br>在根据上面行和列分别会划分成常数段一次函数的结论，可以得到整个矩形会被划分成常数个行和列为固定一次函数的区间。因此对于每个区间分别列出式子，推一下就可以发现是个分别求和的形式，用二维前缀和维护即可。</p>
]]></content>
  </entry>
  <entry>
    <title>二分图学习笔记</title>
    <url>/bipartite-graph/</url>
    <content><![CDATA[<p>二分图又称二部图，是图论中一种特殊模型。对于一个无向图，如果可以把他的顶点分为两个互不相交的子集，并且图中的每一条边，所关联的两个顶点都分别属于两个不同的顶点集，则称该图为二分图。显然二分图中不存在奇数环，如果出现的话无法被划分到任何集合里。  </p>
<a id="more"></a>

<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p>通过 $dfs$ 或者 $bfs$ 对一张图染色（即染色法，共有两种颜色），对于每一条边，使其两个节点的颜色不同。当一个点的颜色已经被确定时，该结点的颜色与当前应该染的颜色冲突，则说明这张图不是二分图。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> color)</span> </span>&#123;<span class="comment">//u为当前遍历到的结点，color为该点应该染的颜色，用1， 2来表示</span></span><br><span class="line">    <span class="keyword">if</span> (col[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[u] != color) <span class="keyword">return</span>;<span class="comment">//说明这张图不是二分图</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        col[u] = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        dfs(v, <span class="number">3</span> - color);<span class="comment">//边的两个端点颜色不同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。（如图三红边）<br><img src="https://i.loli.net/2018/07/05/5b3ddcb139508.png" alt="1.png"> <img src="https://i.loli.net/2018/07/05/5b3ddcb144938.png" alt="2.png">   <img src="https://i.loli.net/2018/07/05/5b3ddcb145f58.png" alt="3.png">   <img src="https://i.loli.net/2018/07/05/5b3ddcb14751d.png" alt="4.png"><br>相应的，属于「匹配」的边为匹配边，不属于匹配的边为为匹配的边。与匹配边相连的点为匹配点，反之则为未匹配点。  </p>
<h2 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h2><p>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。例如图四所示的红边，注意一张图的最大匹配方案不一定唯一。 （见图四） </p>
<h2 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h2><p>对于一张图的某个匹配来说，如果该图的所有点都是匹配点，那么称该匹配为该图的「完美匹配」（图四）。显然，完美匹配一定是最大匹配。  </p>
<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p>一种求最大匹配的算法。  </p>
<h2 id="交叉路"><a href="#交叉路" class="headerlink" title="交叉路"></a>交叉路</h2><p>从一个未匹配点出发，<strong>依次</strong>经过未匹配边、匹配边、未匹配边、匹配边……最终到达另一个点的路径。特别的，一条未匹配边与两个未匹配点组成的路径也是交叉路  </p>
<h2 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h2><p>最后一个端点为未匹配点的交叉路。特别的，一条未匹配边与两个未匹配点组成的路径也是增广路。增广路的首尾两条边都是未匹配边，首尾两个点都是未匹配点，并且边数一定是奇数。既然是奇数，那么增广路中的未匹配边一定比匹配边多一条。  </p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>根据增广路中未匹配边比匹配边多一条的性质，那么只要把增广路中的边的身份翻转，得到的新的匹配中的边数就会多一。因此匈牙利算法实质上是在不断地找增广路来改进当前的匹配。由此得出，最大匹配中一定不存在增广路，如果有增广路的话，该匹配就可以改进，就不是最大匹配了。  </p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>从二分图的一边开始，以每个点为起点进行 $dfs$ 或者 $bfs$ ，每当搜索到一条增广路时，结束搜索。那么显然以一个点为起点只能找到一条增广路。每找到一条增广路，匹配数便加一。注意实际实现的时候并没有把边标记为匹配边与未匹配边。连接两个匹配点的路径显然是匹配边。  </p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;<span class="comment">//vis数组用来标记该点有没有在本次dfs中被遍历过</span></span><br><span class="line">            vis[v] = <span class="literal">true</span>;<span class="comment">//更改状态，标记为遍历过</span></span><br><span class="line">            <span class="keyword">if</span> (!pre[v] ||dfs(pre[v])) &#123;<span class="comment">//pre数组记录该匹配边中的另一个点，</span></span><br><span class="line">                <span class="comment">//如果为空的话显然就是一条增广路。如果不为空，则遍历该数组中记录的点，并返回能否找到增广路</span></span><br><span class="line">                pre[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//已经找到增广路了，结束遍历，返回结果。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//未找到增广路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><p><strong>最大匹配数</strong>：最大匹配的边数。<br><strong>最小点覆盖数</strong>：尽可能少地选择一些点，使得图中任意一条边都至少有一个顶点被选择。<br><strong>最小路径覆盖数</strong>：对于一张 $DAG$ ，选取最少的简单路径数，使得每个顶点只属于一条路径。路径可以仅由一个点组成。换言之，按照这样的路径能遍历到所有的点，且每个点仅被遍历一次。<br><strong>最小边覆盖</strong>：选取最少的边，使得图中任意一个点都是最小边覆盖集的邻接顶点，一条边只能覆盖两条边。（特别地，孤立点无法被任何边覆盖，所以含孤立点的图不存在边覆盖）<br><strong>最大独立集</strong>：选取最多的点，这些点彼此之间没有连边。<br><strong>最大团</strong>：当且仅当该子图是一张完全图（任意两个点之间都有边的图），且该子图不属于该图中的任何完全子图时为该图的最大团</p>
<h3 id="最小点覆盖数"><a href="#最小点覆盖数" class="headerlink" title="最小点覆盖数"></a>最小点覆盖数</h3><p>最小点覆盖数 = 最大匹配数（ $\text{König}$ 定理）。<br>证明过于复杂，因此不在此贴出，请自行百度。</p>
<h3 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h3><p>最大独立集的点数 = 点数 - 最大匹配数（或者最小点覆盖数）<br>这条定理可以用反证法证明，需要一点前置知识，阅读以下内容之前请务必理解如何证明最小点覆盖数 = 最大匹配这条定理，以及二分图的最小路径覆盖点集如何求出。<br>如果你已经准备好了，那请继续阅读。<br>把二分图的最小点覆盖集删除之后，剩余的点之间如果边，那么最小点覆盖集必然无法覆盖这些边。但是最小点覆盖集必然可以覆盖所有的边，所以上述与最小点覆盖集的性质冲突，故不成立，即最小点覆盖集以外的点之间必然没有边。所以：最大独立集的点数 = 点数 - 最小点覆盖数。又因为最小点覆盖数 = 最大匹配得，所以：最大独立集的点数 = 点数 - 最大匹配数。</p>
<h3 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h3><p>最小路径覆盖数 = 点数 - 相应二分图的最大匹配数<br>把无向图的每个点拆成两个，分别属于构造出的二分图的两边（对于点 $x$ ，由 $x$ 拆得的左边的点与右边的点分别为$x_1， x_2$）。设有边 $(u, v)$ ，那么在二分图中便有边 $(u_1, v_2)$ 。因为原图是 $DAG$ ， 那么每条路径上的点除终点之外，都有且仅有一个后继。假设点都各自是一条路径，那么路径数与点数相同。二分图中每有一条匹配边，便会使一个点有且仅有一个后继。这也意味着这个点不能成为路径的终点。而路径有唯一的终点，所以每有一个匹配，路径便会少一。那么便能得到：最小路径覆盖数 = 点数 - 相应二分图的最大匹配数   </p>
<h3 id="最小边覆盖"><a href="#最小边覆盖" class="headerlink" title="最小边覆盖"></a>最小边覆盖</h3><p>对于二分图：</p>
<p>最小边覆盖数 = 点数 - 最大匹配数 = 最大独立集数。</p>
<p>优先选择匹配边，因为选取最大匹配集中的点都会让两个点被覆盖。然后剩下的所有的边要么是连接两个匹配点，要么连接一个匹配点和一个未匹配点，选取后者。就是说选取完匹配边之后，再对于每个未覆盖点选取一条连接该点和一个覆盖点的边，这样的边集即为最小边覆盖集。</p>
<p>所以一开始给出的式子也就可以推出了。</p>
<p>最大匹配数 + （点数 - 2 * 最大匹配数） = 点数 - 最大匹配数</p>
<p>（感谢<a href="https://blog.aor.sd.cn/">wyh</a>聚聚用几句话就给我讲懂了证明）<img src="https://i.loli.net/2018/11/28/5bfe7f3bc0925.png" alt="img"></p>
<h3 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h3><p>最大团点数 = 点数 - 相应的补图的最大匹配数<br>构造出该无向图的补图后，最大团实际上就是补图的最大独立集， 故有：最大团点数 = 点数 - 相应的补图的最大匹配数。</p>
]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijsktra算法</title>
    <url>/dijkstra/</url>
    <content><![CDATA[<p>Dijkstra算法是一种用于求最短路径的算法，用于求一个节点到其他所有节点的最短路径。与其他的最短路径算法一样，都采用松弛操作，并且运用了贪心的思想。适用于处理不存在负边权的稀疏图，算法的时间复杂度为 $O(N^2)$ ,采用堆优化后可以达到 $O(N\log N)$ 。</p>
<a id="more"></a>
<p>下面给出堆优化写法，题目参考<a href="https://www.luogu.org/problemnew/show/1339">Heat Wave</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    <span class="keyword">bool</span> used;</span><br><span class="line">    Edge *firstEdge;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *s, Node *t, <span class="keyword">int</span> w) : s(s), t(t), w(w), next(s-&gt;firstEdge)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t, <span class="keyword">const</span> <span class="keyword">int</span> &amp;w)</span> </span>&#123;</span><br><span class="line">    node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s], &amp;node[t], w);</span><br><span class="line">    node[t].firstEdge = <span class="keyword">new</span> Edge(&amp;node[t], &amp;node[s], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        node[i].dist = INT_MAX;</span><br><span class="line">        node[i].used = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Node*&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Node*&gt; &gt;, greater&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Node*&gt; &gt; &gt; heap;</span><br><span class="line">    heap.push(<span class="built_in">make_pair</span>(node[s].dist = <span class="number">0</span>, &amp;node[s]));</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty()) &#123;</span><br><span class="line">        Node *u = heap.top().second;</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;used) <span class="keyword">continue</span>;</span><br><span class="line">        u-&gt;used = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge *e = u-&gt;firstEdge; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e-&gt;t-&gt;dist &gt; e-&gt;w + u-&gt;dist) &#123;</span><br><span class="line">                e-&gt;t-&gt;dist = e-&gt;w + u-&gt;dist;</span><br><span class="line">                heap.push(<span class="built_in">make_pair</span>(e-&gt;t-&gt;dist, e-&gt;t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node[t].dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dijkstra(n, s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>【SDOI2009】HH的项链</title>
    <url>/hh-necklace/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.org/problemnew/show/P1972">LuoguP1972</a></p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$\text{HH}$  有一串由各种漂亮的贝壳组成的项链。$\text{HH}$ 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。$\text{HH}$ 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行：一个整数 $\text{N}$，表示项链的长度。</p>
<p>第二行：$\text{N}$  个整数，表示依次表示项链中贝壳的编号（编号为 $0$ 到 $1000000$ 之间的整数）。</p>
<p>第三行：一个整数 $\text{M}$，表示 $\text{HH}$ 询问的个数。</p>
<p>接下来 $\text{M}$  行：每行两个整数，$\text{L}$  和 $\text{R}（1  \leq L \leq R \leq N）$，表示询问的区间。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>$\text{M}$ 行，每行一个整数，依次表示询问对应的答案。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 3 5</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">2 6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>数据范围：</p>
<p>对于 $100 %$ 的数据，$ n \leq 500000, m \leq 500000$  </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意很简单明了，就是求区间不同的数的个数，可以离线</p>
<p>主席树当然是可以做的，主席树可以在线解决。<del>但是我好久没写了，而且常数还大</del>，莫队也可以跑过去</p>
<p>但是有点大材小用，树状数组离线就够了</p>
<p>分析一下题目的性质，不难看出，如果查询的区间 $[l, r]$ 内有重复的数，这个重复的数只会在一个位置被计算贡献，其他位置的贡献要去掉。</p>
<p>先把询问读进来，然后按照右端点的位置升序排序，用树状数组记录贡献，某一个询问的答案用树状数组查询一下前缀和差分一下就可以得到。但是这样是会重复计算相同的数的贡献的，考虑去重。</p>
<p>对于一个数 $\text{w}$，如果它在序列中多次出现，那么我们按照这样排序之后，只需要保留最靠右的 $\text{w}$ 的贡献，因为对于一次右端点在 $\text{w}$ 右边的查询，这次查询要么不包含任意一个 $\text{w}$，要么包含一个或者多个。我们只保留最靠右的那一个的贡献，就会消除掉重复的贡献，故思路是对的。开一个数组 $\text{last[i]}$ 表示 $\text{i}$ 最后一次出现的位置，如果出现过就去掉前面的贡献</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i = l; i &lt;= r; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[MAXN], t[MAXN], last[MAXN], now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x))</span><br><span class="line">        t[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x))</span><br><span class="line">    	ret += t[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(r) - sum(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pro</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pro &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; other.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ask[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;ask[i].l, &amp;ask[i].r);</span><br><span class="line">        ask[i].pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(ask + <span class="number">1</span>, ask + m + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        rep(j, now, ask[i].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[a[j]]) add(last[a[j]], <span class="number">-1</span>);</span><br><span class="line">            add(j, <span class="number">1</span>);</span><br><span class="line">            last[a[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ask[i].pos] = query(ask[i].l, ask[i].r);</span><br><span class="line">        now = ask[i].r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>离线</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>【LuoguP1402】酒店之王</title>
    <url>/king-of-hotels/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1402">LuoguP1402</a></p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>XX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。</p>
<p>有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间，吃到喜欢的菜）。</p>
<p>这里要怎么分配，能使最多顾客满意呢？</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行给出三个正整数表示 $\text{n,p,q}( \leq 100)$。</p>
<p>之后 $\text{n}$ 行，每行$\text{p}$ 个数包含 $0$ 或 $1$，第 $\text{i}$ 个数表示喜不喜欢第 $\text{i}$ 个房间（ $1$ 表示喜欢，$0$ 表示不喜欢）。</p>
<p>之后 $\text{n}$ 行，每行 $\text{q}$ 个数，表示喜不喜欢第 $\text{i}$ 道菜。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>最大的顾客满意数。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2 2</span><br><span class="line">1 0</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>好像就是两个二分图，和在一块是一个三分图？（姑且这么叫吧）</p>
<p>愣是没想出来怎么用二分图做</p>
<p>但是最大流做法还是很显然的</p>
<p>因为每个人的贡献最大是 $1$，所以要把表示人的点拆点，拆成两个，然后在表示同一个人的两个点之间连一条容量为 $1$ 的边</p>
<p>首先要拆点，一共有六排点，一个超级源点在最左边，$\text{p}$ 个表示房间的点在第二排，$\text{n}$ 个人拆点之后在第三排和第四排，第五排是表示菜的 $\text{q}$ 个点，最后一排是超级汇点</p>
<p>细节上，根据限制，超级源点要向所有表示房间的点连一条容量为 $1$ 的边，所有表示菜的点向超级汇点连一条容量为 $1$ 的边。如果某个人喜欢谋个房间，便从这个房间向这个人连一条容量为 $1$ 的边；如果某个人喜欢某道菜，便从这个人向这道菜连一条容量为 $1$ 的边。</p>
<p>最后跑一下最大流就好了，我用的是 $\text{Dinic}$ </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> * <span class="number">4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">300</span> * <span class="number">300</span> * <span class="number">3</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, flow, next;</span><br><span class="line">&#125; edge[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cur[MAXN], cnt = <span class="number">1</span>, tot;</span><br><span class="line"><span class="keyword">int</span> deep[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">    edge[cnt].flow = flow;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line">        deep[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    deep[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">            <span class="keyword">if</span> (!deep[v] &amp;&amp; edge[e].flow) &#123;</span><br><span class="line">                deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> limit = INT_MAX)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !limit) <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;e = cur[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; (f = dfs(v, t, <span class="built_in">std</span>::min(limit, edge[e].flow)))) &#123;</span><br><span class="line">            ans += f;</span><br><span class="line">            limit -= f;</span><br><span class="line">            edge[e].flow -= f;</span><br><span class="line">            edge[e ^ <span class="number">1</span>].flow += f;</span><br><span class="line">            <span class="keyword">if</span> (!limit) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s, t)) ret += dfs(s, t);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p, q;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;p, &amp;q);</span><br><span class="line">    tot = <span class="number">2</span> * n + p + q + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        add(p + i, p + n + i, <span class="number">1</span>);</span><br><span class="line">        add(p + n + i, p + i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                add(j, p + i, <span class="number">1</span>);</span><br><span class="line">                add(p + i, j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= q; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                add(p + n + i, p + <span class="number">2</span> * n + j, <span class="number">1</span>);</span><br><span class="line">                add(p + <span class="number">2</span> * n + j, p + n + i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++) add(<span class="number">0</span>, i, <span class="number">1</span>), add(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) add(p + <span class="number">2</span> * n + i, tot, <span class="number">1</span>), add(tot, p + <span class="number">2</span> * n + i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dinic(<span class="number">0</span>, tot));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title>noip2018总结与反思</title>
    <url>/noip2018/</url>
    <content><![CDATA[<p>NOIP2018游记</p>
<a id="more"></a>

<h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>从上午8点左右，一直颠到下午1点才到昌邑一中。</p>
<p>前一天机房里就疯狂出橙，我死活不出= =，坐车的时候zzh还大喊“我出橙了！还是金橙！”</p>
<p>我：“mmp，欧吃矛”</p>
<p>团长说我没出橙说明我把rp攒到noip考场上了</p>
<p>食堂里的饭和SDSC2018的时候的饭基本没什么变化，还是那么油腻以及有大量菌类= =</p>
<p>去主楼抽签之前，我奶我自己在昌邑一中考试，结果抽到了潍坊工业学校= =，还TM是除了备用考场之外最后一个考场= =</p>
<p>下午在一个都是鸽子的亭子周围和好多人面基了，我也忘了牌子上写的是什么了，姑且就叫它鸽子亭吧(手动滑稽)</p>
<p>以下是我认识的鸽亭面基大会的成员：</p>
<p>wqy,tqc,rqy,hzy,cjc,tqc,yt,dzm,refun,hc</p>
<p>晚上试机的时候，巴车延迟了= =</p>
<p>在等巴车的时候据说还有人在签到，吐槽一下昌邑一中的办事效率</p>
<p>比较庆幸的是考试用win7，还和wqy神犇一个考场</p>
<p>键盘键程超级短，前一天还在用青轴的我感到极度不适。</p>
<p>试机的时候写了一发线段树和lis，旁边的小哥在写最短路</p>
<p>回去的时候在群里看到sqy神仙试机30分钟的时间就写出了rbt ，orz</p>
<p>回宿舍洗刷完就关灯躺床上打算睡觉了，但是前几天睡的比较晚，生物钟调不过来，然后聊天聊到11点多才睡</p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>早上不知道因为什么四点来钟就行了，躺床上想再睡会但是一直睡不着，盖着被还是感觉很冷。</p>
<p>无比清醒地躺倒6点多才和大家一起起床吃饭</p>
<p>吃完早餐去餐厅楼下买了一瓶景甜，一罐红牛，一瓶脉动，很怕自己考场上睡着，再超市找了好几圈才找到红牛</p>
<p>耽误了时间，差点没赶上班车。。。</p>
<p>开始考试的时候挺紧张的，虽然今年只是练兵，无关紧要，但还是想要考好</p>
<p>T1拿到题就出来怎么做了，然后没想好拿什么维护就直接开始写线段树= =，虽然十分钟就写完了，但是怕被卡常还是老老实实换成了st表。换成st表反而还调了很久= =，维护下标没写过几次</p>
<p>T2读完题没想出来是什么意思，然后读了两三遍之后发现就是删去里面可以被其他数若干倍和表示的就可以了。然后满脑子数论，“大凯的疑惑？”。然后想到一个数的倍数，两个数的倍数和，三个数的倍数和……</p>
<p>听团长昨晚在宿舍里提了一嘴裴蜀定理，`然后就满脸自闭地推式子，发现并不会做= =，死活想不到是个完全背包</p>
<p>然后打了前三十分开始看下一题。</p>
<p>T3读错题了，考场上没看到要首尾相接，但还是觉得是个二分答案，但是考场上愣是没想到怎么检验，我还以为像去年普及组T4一样dp检验，但是没想出来方程和转移。部分分写了链和m=1的40分。m=1的部分分一开始还写假了，输出边权和= =，最后十分钟才发现选一条最长的，然后收卷前五分钟写完树的直径= =</p>
<p>还有就是链上的二分答案我怕写挂，是这么写的（跑民间数据的时候稳得一批）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = min, r = sum, mid;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check1(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (check1(i)) &#123;</span><br><span class="line">            mid = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mid);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>出考场之后wqy告诉我贪心检验，记一下最长剩余权值= =</p>
<p>Day1：100 + 30 + 40滚粗</p>
<p>晚上在宿舍里满脑子Day2翻盘</p>
<p>和昨晚一样早躺在床上但是睡不着</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>早上6点来钟就醒了，手机闹钟过了几分钟才响</p>
<p>照例买了红牛和景甜，但是没买脉动，三瓶太多喝不了</p>
<p>等颓子ycy看番，差点真赶不上班车，迟到×2，团长和ycy的车已经出发了</p>
<p>在考场上心态挺崩的，满脑子想着Day2翻盘</p>
<p>T1树的那部分分挺好拿的，优先队列维护出边dfs就可以了，考场上几分钟写完，时间复杂的O(nlogn)</p>
<p>然后开始想基环树的那40分，满脑子想着怎么贪心，没看到枚举断边就可以过，一个半小时之后觉得再想就亏了，扔了开始看T2和T3，这时候其实就很紧张了</p>
<p>T2题面很长我还没读懂，但貌似是个数学题我就觉得不太可做，读了两三遍之后扔了开始看T3，事后发现很多神仙也放弃T2了</p>
<p>T3我一开始读错题了，还以为是个裸的二分图染色，敲完之后开始带样例，小样例带过，大样例挂了之后发现不对劲了。</p>
<p>挂掉之后有点不知所措，看着数据约定的表格不知道该写哪一部分，几分钟之后才回过神来写前五十分。</p>
<p>前五十分是每次询问跑一遍dp，貌似和没有上司的舞会差不多。考场上写挂了，样例都带不过去，心态崩到不知道怎么调试，干等着肉眼看到收卷</p>
<p>Day2:60滚粗</p>
<p>赛后民间数据测的成绩都在230-245这个范围</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol>
<li>整体上心态很差，太紧张了，由于心态引起了很多失误</li>
<li>D1T1没分析好需求就开始写线段树，浪费10分钟</li>
<li>做D1T2的时候不太灵活，没想到完全背包，说明对于完全背包还是不够熟练，白丢70分</li>
<li>D1T3很尽力地打了部分分，但是读错题还是说明心态太差以及不够细心</li>
<li>D2T1很紧张地没根据时间复杂度做题，结果浪费啷个小时</li>
<li>D2T2直接略过好像是对的，我确实是做不出来。数学太差以后要恶补</li>
<li>D2T3心态崩到写不出暴力</li>
</ol>
<p>主要的问题还是说考场上太紧张了，现在分析一下，D2T3的50分暴力和D1T2的70分正解我状态好其实是可以拿到的。</p>
<p>不过好在这次除了D2T3的暴力，其他的都没有写挂（至少民间数据是这样）</p>
<p>回去的路上团长给我说如果这是场模拟赛的话，我肯定心态就会好很多，分数也会高很多</p>
<p>想想挺有道理的，今年NOIP我最大的问题就是心态。考试的时候想的太多了，太想拿成绩证明一下自己，然后负担很重紧张也就在所难免。</p>
<p>希望明年能放松点好好发挥吧。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>看一眼这篇文章，写得有点乱</p>
<p>鄙人文笔不好，而且思维还有点混乱，但还是想写一篇总结&amp;游记&amp;反思性质的文章纪念一下第一次参加NOIP提高组，所以还是发表挂上吧。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>【LYOI】20180916T2 Solution</title>
    <url>/solution/</url>
    <content><![CDATA[<p>Solution for LYOI contest【2018.9.16.T2】</p>
<a id="more"></a>

<p>题目的意思就是说给你一些截距为 $0$ 的二次函数，然后让你求对于特定的 $x$ ，最大的函数值是多少。</p>
<p>首先二次函数是抛物线，不太好做。</p>
<p>其实可以把这些二次函数拆成两条一次函数，两条函数关于 $x$ 轴对称，分别对应 $x$ 为为正负两种情况。</p>
<p>然后你就有了两个有若干一次函数的平面直角坐标系。</p>
<p>然后只需要求对于不同的 $x$ 的取值范围，哪段函数更优就可以了，对于正负两种情况分别维护上凸壳和下凸壳（貌似是斜率优化 $\text{QAQ}$ ）。</p>
<p>其实这个单调队列就可以实现，过程有点像初中数学里给你两个直线，求 $x$ 的哪些取值范围哪条直线的函数值更大。常见套路是求直线的交点，据此判断大小，求凸壳也是如此，凸壳上的点都是直线的交点嘛。（个人感觉凸壳就是分段函数QAQ）</p>
<p>对于两个一次函数$ax+b$和$a’x+b’$，其交点的横坐标可以用一元一次方程求得。</p>
<p>$$ax+b=a’x+b’$$ </p>
<p>$$ax-a’x=b’-b$$ </p>
<p>$$x=\frac{b’-b}{a-a’}$$ </p>
<p>如果求上凸壳的话，显然 $x$ 的值越大，这条直线的斜率就越大，也就更优。下凸壳也是类似的道理。</p>
<p>算法流程如下：</p>
<ul>
<li>对这些直线按照斜率和截距从小到大的顺序排序，其中斜率的优先级大于截距</li>
<li>然后用单调队列求出上凸壳。</li>
<li>对于任意的 $x$ ，只需要判断其正负，然后在凸壳上二分查找，即可求得最优值。</li>
</ul>
<p>具体实现见代码(这么丑的代码当然不是我写的QAQ)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> U unsigned</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for(R int i = a;i &lt;= b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RFOR(i,a,b) for(R int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(i,a) memset(i,a,sizeof(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BR printf(<span class="meta-string">&quot;--------------------\n&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&#x27;=&#x27;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO&#123;<span class="comment">//fread,读入优化，不需要看</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> OUT_SIZE 100000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">    <span class="keyword">bool</span> IOerror=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (p1==pend)&#123;</span><br><span class="line">            p1=buf; pend=buf+fread(buf,<span class="number">1</span>,BUF_SIZE,<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">if</span> (pend==p1)&#123;IOerror=<span class="number">1</span>;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;<span class="keyword">return</span> ch==<span class="string">&#x27; &#x27;</span>||ch==<span class="string">&#x27;\n&#x27;</span>||ch==<span class="string">&#x27;\r&#x27;</span>||ch==<span class="string">&#x27;\t&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">        <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">        <span class="keyword">for</span> (;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">        <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">        <span class="keyword">for</span> (;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> ll</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> OUT_SIZE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> BUF_SIZE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> size1,size2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Values</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Values &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == other.a) <span class="keyword">return</span> b &lt; other.b;<span class="comment">//注意优先级</span></span><br><span class="line">        <span class="keyword">return</span> a &lt; other.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;v1[MAXN],v2[MAXN],s1[MAXN],s2[MAXN];<span class="comment">//函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,Q;</span><br><span class="line"><span class="comment">// y=ax+b;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Values v[],Values s[],<span class="keyword">int</span> &amp;size)</span></span>&#123;<span class="comment">//单调队列求凸壳</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v + <span class="number">1</span>,v + N + <span class="number">1</span>);<span class="comment">//先排序</span></span><br><span class="line">    FOR(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        <span class="keyword">while</span>((size &gt;= <span class="number">1</span> &amp;&amp; s[size].a == v[i].a) || (size &gt;= <span class="number">2</span> &amp;&amp; (<span class="number">1l</span>l * (s[size<span class="number">-1</span>].b - s[size].b) * (v[i].a - s[size<span class="number">-1</span>].a)) &gt;= (<span class="number">1l</span>l * (s[size<span class="number">-1</span>].b - v[i].b) * (s[size].a - s[size<span class="number">-1</span>].a))))<span class="comment">//去重以及通过直线交点的横坐标判断哪条直线更优</span></span><br><span class="line">            size--;</span><br><span class="line">        s[++size] = v[i];<span class="comment">//入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">val</span><span class="params">(<span class="keyword">const</span> Values &amp;u,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//求函数值</span></span><br><span class="line">    <span class="keyword">return</span> (LL)u.a * x + u.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">find_max</span><span class="params">(Values s[],<span class="keyword">int</span> size,<span class="keyword">int</span> x)</span></span>&#123;在凸包上二分查找最优值</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = size;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(val(s[mid],x) &gt; val(s[mid + <span class="number">1</span>],x))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)val(s[l],x)*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    read(N);read(Q);</span><br><span class="line">    FOR(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        read(v1[i].a);read(v1[i].b);</span><br><span class="line">        v2[i].a = -v1[i].a;v2[i].b = -v1[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    pre(v1,s1,size1);</span><br><span class="line">    pre(v2,s2,size2);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;read(x);</span><br><span class="line">        <span class="keyword">if</span>(!x)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,-find_max(s2,size2,x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,find_max(s1,size1,x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>solution</tag>
        <tag>斜率优化</tag>
        <tag>计算几何</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
        <tag>单调队列</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>【LYOI】20180923 Solution</title>
    <url>/solution2018123/</url>
    <content><![CDATA[<p>Solution for LYOI contest 【2018.9.23】</p>
<a id="more"></a>

<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个由括号组成的字符串，有若干次询问，每次询问要求输出从 $[l,r]$ 中选出若干括号，组成的最长的括号序列的长度。（注意是序列不是子串，序列可以不连续）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据面向数据范围编程的原则，发现 $O(m\log_2n)$ 的算法可以过。</p>
<p>区间问题很容易让人想到线段树，实际上本题符合线段树维护数据的原则，不过需要在查询的时候使用一个技巧。</p>
<p>线段树的每个节点维护三个信息，分别是本区间内未匹配的左括号数量，未匹配的右括号的数量，以及完成匹配的括号的对数，分别用 $lm,rm,num$ 来表示。</p>
<p>这类问题的合并是核心，维护了上述三个信息之后不难想到如何合并。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">std</span>::min(lc-&gt;lm, rc-&gt;rm);<span class="comment">//求出左儿子未匹配的左括号和右儿子未匹配的右括号的最小值</span></span><br><span class="line">        num = lc-&gt;num + rc-&gt;num + t;<span class="comment">//合并之后这些括号可以匹配</span></span><br><span class="line">        lm = lc-&gt;lm + rc-&gt;lm - t;<span class="comment">//去掉新匹配的括号</span></span><br><span class="line">        rm = lc-&gt;rm + rc-&gt;rm - t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个问题是如何查询</p>
<p>查询 $[l,r]$ 这个区间的答案时，这个区间会被分成若干个长度为 $\text{2}$ 的整数次幂的区间。线段树递归合并的顺序是从左到右的，那么我们可以记录已经处理的当前区间左边区间的 $lm,rm,num$ ，再把当前区间和左边这个区间合并即可。</p>
<p>贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, SegmentTree *&amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; r == right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">std</span>::min(k-&gt;lm, rm);<span class="comment">//和pushUp一模一样的合并操作</span></span><br><span class="line">            k-&gt;num = k-&gt;num + num + t;</span><br><span class="line">            k-&gt;lm = k-&gt;lm + lm - t;</span><br><span class="line">            k-&gt;rm = k-&gt;rm + rm - t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;query(left, right, k);<span class="comment">//线段树我就不讲了吧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;query(left, right, k);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;query(left, mid, k), rc-&gt;query(mid + <span class="number">1</span>, right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> lm, rm, num;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> newNode(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode(l, r, build(l, mid), build(mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">std</span>::min(lc-&gt;lm, rc-&gt;rm);</span><br><span class="line">        num = lc-&gt;num + rc-&gt;num + t;</span><br><span class="line">        lm = lc-&gt;lm + rc-&gt;lm - t;</span><br><span class="line">        rm = lc-&gt;rm + rc-&gt;rm - t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[l] == <span class="string">&#x27;(&#x27;</span>) lm++;</span><br><span class="line">            <span class="keyword">else</span> rm++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lc-&gt;init(), rc-&gt;init();</span><br><span class="line">        pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, SegmentTree *&amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; r == right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">std</span>::min(k-&gt;lm, rm);</span><br><span class="line">            k-&gt;num = k-&gt;num + num + t;</span><br><span class="line">            k-&gt;lm = k-&gt;lm + lm - t;</span><br><span class="line">            k-&gt;rm = k-&gt;rm + rm - t;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) lc-&gt;query(left, right, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) rc-&gt;query(left, right, k);</span><br><span class="line">        <span class="keyword">else</span> lc-&gt;query(left, mid, k), rc-&gt;query(mid + <span class="number">1</span>, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *root, pool[MAXN &lt;&lt; <span class="number">1</span>], *tail = pool, *k;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;l = l, ret-&gt;r = r, ret-&gt;mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    ret-&gt;lm = ret-&gt;rm = ret-&gt;num = <span class="number">0</span>;</span><br><span class="line">    ret-&gt;lc = lc, ret-&gt;rc = rc;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    k = newNode(<span class="number">1</span>, n, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    root = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    root-&gt;init();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        k-&gt;lm = k-&gt;rm = k-&gt;num = <span class="literal">false</span>;</span><br><span class="line">        root-&gt;query(l, r, k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k-&gt;num &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $\text{n}$ 个收益都为 $\text{1}$ 的物品，以及 $\text{n}$ 组 $b_i,k_i$ ，表示对于第 $\text{i}$ 个物品，可以花$b_i+k_i$个金币进行购买，其中 $b_i$ 比较珍贵，要尽可能少使用。</p>
<p>给定 $\text{m}$ 种购买途径，每种途径只能用一次。 $a_i$ 表示第 $\text{i}$ 种途径需要花费的金币数量。</p>
<p>求最多能购买的物品数量和满足购买的物品最多的前提下最小的 $b_i$ 消耗和。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>对于第一问，把 $a_i$ 排序，然后依次处理。</p>
<p>对于 $a_i$ ，显然使用这种途径去买能买的物品中$b_i+k_i$最小的是最优的，这样就求出了最大物品数。</p>
<p>对于第二问，将使用的购买方法取出，按ai从大到小依次贪心，在物品中选择可以使用当前购买方法的且 $k_i$ 最大的物品，可以用堆实现 。</p>
<p>具体细节看代码吧。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b, k;</span><br><span class="line">&#125; h[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.k + a.b &lt; b.k + b.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(h + <span class="number">1</span>, h + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="built_in">std</span>::sort(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i].k + h[i].b &gt;= a[cnt] &amp;&amp; cnt &lt;= m) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cnt);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (h[i].k + h[i].b &lt; a[cnt] &amp;&amp; cnt &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            sum += <span class="built_in">std</span>::max(a[cnt--] - q.top(), <span class="number">0</span>);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h[i].k + h[i].b &gt;= a[cnt]) &#123;</span><br><span class="line">            q.push(h[i].k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += <span class="built_in">std</span>::max(a[cnt--] - q.top(), <span class="number">0</span>);</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 $s,p$ 两个字符串，求在 $s$ 串中删除若干字符后的 $p$ 串的数量。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>无脑 $\text{DP}$ 啊QAQ</p>
<p>设 $f[i][j]$ 表示 $s$ 的前 $i$ 个字符中，删去 $j$ 个字符之后 $p$ 串的最大数量。</p>
<p>设 $w[i]$ 表示从 $s$ 的第 $i$ 个字符开始，最小的可以通过删除某些字符来得到 $p$ 串的字符串长度。</p>
<p>转移也很显然了</p>
<ul>
<li><p>不删除，对答案无影响</p>
<p>$$ f[i+1][j]=\max(f[i+1][j],f[i][j]) $$ </p>
</li>
<li><p>删除，对答案无影响</p>
<p>$$ f[i+1][j+1]=\max(f[i+1][j+1],f[i][j]) $$ </p>
</li>
<li><p>删除，对答案有影响</p>
<p>$$ f[i+w[i]][j+w[i]-|p|]=\max(f[i+w[i])[j+w[i]-|p|],f[i][j]+1) $$ </p>
</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e3</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN], p[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN], w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, s, p);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), m = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        w[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == p[t]) t++;</span><br><span class="line">            <span class="keyword">if</span> (t == m) &#123;</span><br><span class="line">                w[i] = j - i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][j] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][j], f[i][j]);</span><br><span class="line">            f[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][j + <span class="number">1</span>], f[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; <span class="number">0</span>)</span><br><span class="line">                f[i + w[i]][j + w[i] - m] = <span class="built_in">std</span>::max(f[i][j] + <span class="number">1</span>, f[i + w[i]][j + w[i] - m]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, f[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][n]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树</tag>
        <tag>solution</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>【JSOI2014】松鼠的新家</title>
    <url>/squirrel/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.org/problemnew/show/P3258">Luogu P3258</a>  </p>
<a id="more"></a>   

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>非常裸的树上路径权值修改与单点查询，可以用树剖实现，也可以树上差分。    </p>
<h3 id="代码（O2）"><a href="#代码（O2）" class="headerlink" title="代码（O2）"></a>代码（O2）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>;</span><br><span class="line"><span class="function">Edge *<span class="title">newEdge</span><span class="params">(Node *s, Node *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = ret * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum, tag;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left == right ? newTree(left, right, <span class="literal">NULL</span>, <span class="literal">NULL</span>) : newTree(left, right, build(left, mid), build(mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        tag += delta;</span><br><span class="line">        sum += (r - l + <span class="number">1</span>) * delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">            lc-&gt;cover(tag);</span><br><span class="line">            rc-&gt;cover(tag);</span><br><span class="line"></span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; right == r) &#123;</span><br><span class="line">            cover(delta);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">            lc-&gt;modify(left, right, delta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            rc-&gt;modify(left, right, delta);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lc-&gt;modify(left, mid, delta);</span><br><span class="line">            rc-&gt;modify(mid + <span class="number">1</span>, right, delta);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == l &amp;&amp; right == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;query(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> rc-&gt;query(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;query(left, mid) + rc-&gt;query(mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *tree, poor[MAXN &lt;&lt; <span class="number">1</span>], *tail = poor;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree *<span class="title">newTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, SegmentTree *lc, SegmentTree *rc)</span> </span>&#123;</span><br><span class="line">    SegmentTree *ret = ++tail;</span><br><span class="line">    ret-&gt;l =l, ret-&gt;r = r;</span><br><span class="line">    ret-&gt;lc = lc, ret-&gt;rc = rc;</span><br><span class="line">    ret-&gt;sum = ret-&gt;tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *firstEdge;</span><br><span class="line">    Node *parent, *top, *son;</span><br><span class="line">    <span class="keyword">int</span> dfn, depth, size;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *s, *t;</span><br><span class="line">    Edge *next;</span><br><span class="line">&#125; po[MAXN &lt;&lt; <span class="number">1</span>], *last = po;</span><br><span class="line"></span><br><span class="line"><span class="function">Edge *<span class="title">newEdge</span><span class="params">(Node *s, Node *t)</span> </span>&#123;</span><br><span class="line">    Edge *ret = ++last;</span><br><span class="line">    ret-&gt;s = s, ret-&gt;t = t;</span><br><span class="line">    ret-&gt;next = s-&gt;firstEdge;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    node[s].firstEdge = newEdge(&amp;node[s], &amp;node[t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    u-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = u-&gt;firstEdge; e; e = e-&gt;next) &#123;</span><br><span class="line">        Node *v = e-&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(v != u-&gt;parent) &#123;</span><br><span class="line">            v-&gt;parent = u;</span><br><span class="line">            v-&gt;depth = u-&gt;depth + <span class="number">1</span>;</span><br><span class="line">            dfs(v);</span><br><span class="line">            u-&gt;size += u-&gt;size;</span><br><span class="line">            <span class="keyword">if</span> (!u-&gt;son || u-&gt;son-&gt;size &lt; v-&gt;size) u-&gt;son = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ts =  <span class="number">0</span>;</span><br><span class="line">    u-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!u-&gt;parent || u != u-&gt;parent-&gt;son) u-&gt;top = u;</span><br><span class="line">    <span class="keyword">else</span> u-&gt;top =  u-&gt;parent-&gt;top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;son) split(u-&gt;son);</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = u-&gt;firstEdge; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t-&gt;parent == u &amp;&amp; e-&gt;t != u-&gt;son) &#123;</span><br><span class="line">            split(e-&gt;t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;top != v-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;top-&gt;depth &lt; v-&gt;top-&gt;depth) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        tree-&gt;modify(u-&gt;top-&gt;dfn, u-&gt;dfn, d);</span><br><span class="line">        u = u-&gt;top-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;dfn &gt; v-&gt;dfn) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">    tree-&gt;modify(u-&gt;dfn, v-&gt;dfn, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;top != v-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;top-&gt;depth &lt; v-&gt;top-&gt;depth) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        ret += tree-&gt;query(u-&gt;top-&gt;dfn, u-&gt;dfn);</span><br><span class="line">        u = u-&gt;top-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;dfn &gt; v-&gt;dfn) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">    ret += tree-&gt;query(u-&gt;dfn, v-&gt;dfn);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        read(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        read(u), read(v);</span><br><span class="line">        addEdge(u, v);</span><br><span class="line">        addEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(&amp;node[<span class="number">1</span>]);</span><br><span class="line">    split(&amp;node[<span class="number">1</span>]);</span><br><span class="line">    tree = SegmentTree::build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> last = a[<span class="number">1</span>];</span><br><span class="line">    tree-&gt;modify(node[last].dfn, node[last].dfn, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tree-&gt;modify(node[last].dfn, node[last].dfn, <span class="number">-1</span>);</span><br><span class="line">        modify(&amp;node[last], &amp;node[a[i]], <span class="number">1</span>);</span><br><span class="line">        last = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tree-&gt;modify(node[last].dfn, node[last].dfn, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree-&gt;query(node[i].dfn, node[i].dfn));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树上差分</tag>
        <tag>树链剖分</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】ST表</title>
    <url>/st/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ST表，稀疏表，用于求解经典的RMQ问题。即区间最值问题。基于倍增思想，利用递推的方式预处理，支持高效的查询，不支持修改  </p>
<a id="more"></a>



<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">22</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        f[i][<span class="number">0</span>] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> LC = (<span class="keyword">int</span>)(<span class="built_in">std</span>::<span class="built_in">log</span>(n)/<span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= LC; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">std</span>::max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> k = (<span class="keyword">int</span>)(<span class="built_in">std</span>::<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">std</span>::max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模板</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】树链剖分</title>
    <url>/tree-chain-split/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>树链剖分是一种维护树上路径信息的算法，它将一棵树剖分成一些不相交的链，保证每个点在且仅在一条链上。并通过线段树、树状数组等数据结构维护信息。</p>
<a id="more"></a>  

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P3384">题目链接</a></h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>重结点：子树中结点数目最多的结点；<br>轻节点：父亲节点中除了重结点以外的结点；<br>重边：父亲结点和重结点连成的边；<br>轻边：父亲节点和轻节点连成的边；<br>重链：由多条重边连接而成的路径；<br>轻链：由多条轻边连接而成的路径；    </p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>把整棵树划分成许多条链，使每个节点都在唯一的链上，对每一条链维护一棵线段树，把在树上的操作转移到线段树上。  </p>
<p>树链剖分的策略是轻重边路径剖分，这种策略可以保证整棵树上的轻边和链的数量都不超过 $O(\log n)$ 。    </p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="剖分"><a href="#剖分" class="headerlink" title="剖分"></a>剖分</h2><p>剖分由两次 $dfs$ 组成，第一遍求出每个节点的大小、父节点、深度、重结点，即 $size, fa, dep, son$ 数组。  </p>
<p>第二遍 $dfs$ 求出每个结点所在的链、 $dfn$ 序，即 $top, dfn$ 数组。（本模板对链的信息除了链顶结点外并没有需要，因此 $top$ 数组实际上记录的是该结点所在链的链顶结点的下标，具体用处见下文）。</p>
<p>对于一个结点，如果该结点不是其父节点的重结点或该结点为根节点，则创建一条以该结点为链顶结点的链，否则该节点与其父节点属于同一条链。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>使用线段树对这棵树进行维护，以 $dfn$ 为新的下标。</p>
<h2 id="查询与修改路径信息"><a href="#查询与修改路径信息" class="headerlink" title="查询与修改路径信息"></a>查询与修改路径信息</h2><p>修改或查询 $u, v$ 之间路径上的信息，采取以下策略。<br>首先假设 $u$ 的深度更大，那么修改或查询 $u$ 所在链的链顶结点到 $u$ 这条路径上所有结点的信息，然后将 $u$ 跳到其链顶结点的父节点。重复以上步骤直到 $u$ 与 $v$ 在同一条链上为止。最后修改或查询两点间上结点路径的信息。</p>
<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>不难看出，上述查询或修改路径的过程，实际上是分别修改或查询了 $u$ 到两点间最近公共祖先的路径与 $v$ 到两点间最近公共祖先的路径，所以不难看出，只需去掉查询与修改路径信息的过程，即可求得最近公共祖先。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, next;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum, add;</span><br><span class="line">&#125; t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root, HA, w[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt, head[MAXN];</span><br><span class="line"><span class="keyword">int</span> size[MAXN], son[MAXN], fa[MAXN], pos[MAXN], dep[MAXN], top[MAXN], dfn[MAXN], ts;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = flag * ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    fa[u] = father;</span><br><span class="line">    dep[u] = dep[father] + <span class="number">1</span>;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span>(v == father) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt; size[v]) &#123;</span><br><span class="line">            maxSize = size[v];</span><br><span class="line">            son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tops)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++ts;</span><br><span class="line">    top[u] = tops;</span><br><span class="line">    pos[ts] = u;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) dfs2(son[u], tops);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span>(v != son[u] &amp;&amp; fa[v] == u) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    t[x].l = left;</span><br><span class="line">    t[x].r = right;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        t[x].sum = w[pos[left]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">    t[x].sum = (t[x &lt;&lt; <span class="number">1</span>].sum + t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    t[x].add = (t[x].add + d) % HA;</span><br><span class="line">    t[x].sum = (t[x].sum + (t[x].r - t[x].l + <span class="number">1</span>) * d) % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].add &amp;&amp; t[x].l != t[x].r) &#123;</span><br><span class="line">        cover(x &lt;&lt; <span class="number">1</span>, t[x].add);</span><br><span class="line">        cover(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, t[x].add);</span><br><span class="line">        t[x].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].sum = (t[x &lt;&lt; <span class="number">1</span>].sum + t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].l == l &amp;&amp; t[x].r == r) &#123;</span><br><span class="line">        cover(x, d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushDown(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span>, l, mid, d);</span><br><span class="line">        update(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, d);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUp(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].l == l &amp;&amp; t[x].r == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[x].sum % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    pushDown(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (query(x &lt;&lt; <span class="number">1</span>, l, mid) + query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveUpdate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[a] != top[b]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]] &lt; dep[top[b]]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">        update(<span class="number">1</span>, dfn[top[a]], dfn[a], d);</span><br><span class="line">        a = fa[top[a]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[a] &gt; dfn[b]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">    update(<span class="number">1</span>, dfn[a], dfn[b], d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solveQuery</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[a] != top[b]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]] &lt; dep[top[b]]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">        ret = (ret + query(<span class="number">1</span>, dfn[top[a]], dfn[a])) % HA;</span><br><span class="line">        a = fa[top[a]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[a] &gt; dfn[b]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">    ret = (ret + query(<span class="number">1</span>, dfn[a], dfn[b])) % HA;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeUpdate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    update(<span class="number">1</span>, dfn[u], dfn[u] + size[u] - <span class="number">1</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeQuery</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">1</span>, dfn[u], dfn[u] + size[u] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Read(n), Read(m), Read(root), Read(HA);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        Read(w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Read(u), Read(v);</span><br><span class="line">        add(u, v);</span><br><span class="line">        add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(root, <span class="number">0</span>);</span><br><span class="line">    dfs2(root, root);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> c, x, y, z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        Read(c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            Read(x), Read(y), Read(z);</span><br><span class="line">            solveUpdate(x, y, z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span>) &#123;</span><br><span class="line">            Read(x), Read(y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, solveQuery(x, y));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">3</span>) &#123;</span><br><span class="line">            Read(x), Read(y);</span><br><span class="line">            treeUpdate(x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">4</span>) &#123;</span><br><span class="line">            Read(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, treeQuery(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【NOIP2015】运输计划</title>
    <url>/transportation-plan/</url>
    <content><![CDATA[<p>给定一颗边权为非负整数的数，以及一些树上路径。选择一条边吗，使其边权变成 $0$ ， 求树上边权和最大的路径的最小值。</p>
<a id="more"></a>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.org/problemnew/show/P2680">LuoguP2680</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先求出给定的这些路径边权和， $dfs$ 的时候预处理出每个点到根节点的路径的边权和，用 $sum$ 表示。用倍增 $LCA$ 求出给定路径端点的最近公共祖先，用 $x, y$ 表示路径端点， $lca$ 表示最近公共祖先，那么这些路径的长度就是</p>
<p>$$sum[x] + sum[y] - 2 * sum[lca]$$ </p>
<p>然后对这些路径按照边权和，以递减的顺序排序。然后二分答案。其单调性体现在，答案越小，这条边权将要变成 $0$ 的边的边权就要越大，就要被更多的路径所包含。对于所有边权和大于答案的路径，当且仅当边权将要修改的那条边被这些路径都包含，答案才有成立的可能。当满足上一个条件，并且边权和最大的路径的边权减去这条边的边权小于或等于答案时，这个答案就是成立的。</p>
<p>怎么求这些路径的公共部分呢？</p>
<p>如果你能联想到序列的话，就不难想到可以使用差分来求。可以把树上的路径拆分成两条链来看。对于树上的每个点，这个点的标记表示的是连接该点与其父节点的边的标记，因为边不容易检索与维护。然后对其子树递归求和即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, t, w, next;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Path</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, lca, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Path &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;len &gt; x.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[MAXN], dif[MAXN], f[MAXN][<span class="number">22</span>], deep[MAXN], sum[MAXN], max;</span><br><span class="line"><span class="keyword">int</span> n, m, num;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x = ret * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    edge[cnt].s = u;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = pre;</span><br><span class="line">    deep[u] = deep[pre] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span> &amp;&amp; deep[u] - (<span class="number">1</span> &lt;&lt; i) &gt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        sum[v] = sum[u] + edge[e].w;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &gt; deep[b]) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">21</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[f[b][i]] &gt;= deep[a]) b = f[b][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">21</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[a][i] == f[b][i]) <span class="keyword">continue</span>;</span><br><span class="line">        a = f[a][i];</span><br><span class="line">        b = f[b][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, u);</span><br><span class="line">        dif[u] += dif[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dif[u] == num) max = <span class="built_in">std</span>::max(max, sum[u] - sum[f[u][<span class="number">0</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dif, <span class="number">0</span>, <span class="keyword">sizeof</span>(dif));</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    max = <span class="number">-2147483647</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; p[i].len &gt; mid; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        dif[p[i].x]++;</span><br><span class="line">        dif[p[i].y]++;</span><br><span class="line">        dif[p[i].lca] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (max == <span class="number">-2147483647</span> || p[<span class="number">1</span>].len - max &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(u), read(v), read(w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        read(p[i].x), read(p[i].y);</span><br><span class="line">        p[i].lca = Lca(p[i].x, p[i].y);</span><br><span class="line">        p[i].len = sum[p[i].x] + sum[p[i].y] - sum[p[i].lca] * <span class="number">2</span>;</span><br><span class="line">        r = <span class="built_in">std</span>::max(r, p[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = binarySearch();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>差分</tag>
        <tag>倍增</tag>
        <tag>二分答案</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>【NOI2010】超级钢琴</title>
    <url>/%E3%80%90NOI2010%E3%80%91%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小Z是一个小有名气的钢琴家，最近C博士送给了小Z一架超级钢琴，小Z希望能够用这架钢琴创作出世界上最美妙的音乐。</p>
<p>这架超级钢琴可以弹奏出 $n$ 个音符，编号为 $1$ 至 $n$ 。第 $i$ 个音符的美妙度为 $A_i$ ，其中 $A_i$ 可正可负。</p>
<p>一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于 $L$ 且不多于 $R$ 。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。</p>
<p>小Z决定创作一首由k个超级和弦组成的乐曲，为了使得乐曲更加动听，小Z要求该乐曲由k个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小Z想知道他能够创作出来的乐曲美妙度最大值是多少。</p>
<a id="more"></a>

<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输入第一行包含四个正整数 $n,k,L,R$ 。其中 $n$ 为音符的个数， $k$ 为乐曲所包含的超级和弦个数， $L$ 和 $R$ 分别是超级和弦所包含音符个数的下限和上限。</p>
<p>接下来 $n$ 行，每行包含一个整数 $A_i$ ，表示按编号从小到大每个音符的美妙度。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输出只有一个整数，表示乐曲美妙度的最大值。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">-6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.    音符1 ~ 2，美妙度为3 + 2 &#x3D; 5</span><br><span class="line">2.    音符2 ~ 3，美妙度为2 + (-6) &#x3D; -4</span><br><span class="line">3.    音符3 ~ 4，美妙度为(-6) + 8 &#x3D; 2</span><br><span class="line">4.    音符1 ~ 3，美妙度为3 + 2 + (-6) &#x3D; -1</span><br><span class="line">5.    音符2 ~ 4，美妙度为2 + (-6) + 8 &#x3D; 4</span><br></pre></td></tr></table></figure>

<p>最优方案为：乐曲由和弦1，和弦3，和弦5组成，美妙度为5 + 2 + 4 = 11。</p>
<p><img src="https://cdn.luogu.org/upload/pic/2609.png" alt="数据范围"></p>
<p>所有数据满足： $-1000 \leq A_i \leq 1000, 1 \leq L \leq R \leq n$ 且保证一定存在满足要求的乐曲。</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P2048">题目链接</a></h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>整理一下这个题的题意，其实就是求序列长度在 $[l, r]$ 范围内的的前 $k$ 大序列的和。</p>
<p>最暴力的想法当然是枚举序列的长度，然后枚举端点，再维护一个记录前k大序列值的数组，每次求到一个新的序列和，暴力更新。</p>
<p>既然是最暴力的想法，当然可以优化，而这道题优化之后就能得到正解。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>既然是求序列长度和，聪明的你有没有想到什么奇技淫巧呢？</p>
<p>这…这不是前缀和吗？</p>
<p>我们可以预处理一个前缀和的数组，这样知道长度和端点之后就可以 $O(1)$ 地求序列和了。</p>
<h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>暴力解法中，有提到枚举区间长度和端点对吧？</p>
<p>我们可以进行另一个优化。</p>
<p>先枚举左端点，这样我们就可以根据左端点的下标和给出的 $l, r$ 来求出右端点的范围了。</p>
<p>根据前缀和的定义，已知左端点之后，只需要最大化从 $1$ 到右端点的前缀和即可。</p>
<p>然而我们已经知道右端点的范围了，那么这就是一个 $RMQ$ 问题。可以用代码简单的 $ST$ 表来解决这个问题，只需进行 $O(n \log_2(n))$ 复杂度的预处理，即可进行 $O(1)$ 时间复杂度的查询。 <del>你非要写线段树也不拦着你。 </del></p>
<h3 id="优化三"><a href="#优化三" class="headerlink" title="优化三"></a>优化三</h3><p>对于每次通过枚举端点求出的序列，定义一个四元组 $(s, t, l, r)$ , $, t$ 分别表示左右端点的下标， $l, r$ 表示右端点的范围。</p>
<p>现在的暴力算法，只剩下求前 $k$ 大的序列这个操作没有优化过了。实际上，动态求前 $k$ 大，堆这种数据结构是再方便不过了，况且$C++$的 $STL$ 库里还有优先队列这种方便的东西。</p>
<p>利用堆以区间长度为关键字，在堆中维护这些四元组。此时的堆为大根堆。</p>
<h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><p>这样的话，先枚举序列的，再利用求在右端点范围内的前缀和最大值，再用堆维护优化三中提到的四元组。</p>
<p>然后，边弹出堆顶，边插入新的四元组 $(s, sum_{max}, l,  t - 1)​$ 和$(s, sum_{max}, t + 1, r)​$。其中 $max​$ 表示区间内前缀和最大的端点的下标。因为如果不插入的话只是以每个点为左端点求最大值，然而这 $k​$ 个序列的左端点可以重复，所以需要把这个右端点扣掉后再压入堆。弹出堆顶 $k​$ 次，和即为答案。这一步</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">22</span>], sum[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, k, L, R;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, l, r, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[t] - sum[s - <span class="number">1</span>] &lt; sum[x.t] - sum[x.s - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;Node&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[x] &gt; sum[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> mx(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;k, &amp;L, &amp;R);</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + w;</span><br><span class="line">        f[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">19</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            f[i][j] = mx(f[i][j - <span class="number">1</span>],  f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + L - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">std</span>::min(n, i + R - <span class="number">1</span>);</span><br><span class="line">        heap.push((Node) &#123;i, i + L - <span class="number">1</span>, right, query(i + L - <span class="number">1</span>, right)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; k) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        Node g = heap.top(); heap.pop();</span><br><span class="line">        ans += sum[g.t] - sum[g.s - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> q1 = query(g.l, g.t - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> q2 = query(g.t + <span class="number">1</span>, g.r);</span><br><span class="line">        <span class="keyword">if</span>(~q1) heap.push((Node) &#123;g.s, g.l, g.t - <span class="number">1</span>, q1&#125;);</span><br><span class="line">        <span class="keyword">if</span>(~q2) heap.push((Node) &#123;g.s, g.t + <span class="number">1</span>, g.r, q2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>堆</tag>
        <tag>ST表</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>【NOIP2010】引水入城</title>
    <url>/water/</url>
    <content><![CDATA[<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://www.luogu.org/problemnew/show/P1514">LuoguP1514</a></p>
<a id="more"></a>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>以第一行的每个点为起点进行 $\text{dfs}$ ，被遍历过的点不要作为起点。这样就能求出那些点能被遍历到。 </p>
<p>如果最后一行不能被全部遍历，那就统计一下没有遍历到的点，然后输出答案。</p>
<p>问题在于最后一行如果可以被全部遍历到，如何最小化蓄水厂的个数。其实如果可以被全部遍历到的话，每个蓄水厂所能到达的最后一行的点是连续的，也就是说一条线段。在此简单地证明一下：</p>
<p>假设有一个点 $y$ 高于其左右两个点，并且左右的点都可以被 $x$ 蓄水厂到达，并且其上方的这个点可以被某个蓄水厂 $z$ 到达。那么现在分成了两种情况。</p>
<ul>
<li>如果 $y$ 上方的点的高度低于 $y$ 那么显然是无解的， $y$ 点无法到达。</li>
<li>如果 $y$ 上方的点的高度高于 $y$ ，那么 $z$ 显然可以到达 $y$ 以及其左右的点，那么 $x$ 其实一定可以与 $z$ 可以到达的某个点相交，也就是说 $x$ 一定可以到达交点之后的 $z$ 能到达的所有的点，故 $x$ 可以到达 $y$ 。</li>
</ul>
<p>得证。</p>
<p> 那么就变成了经典的线段覆盖问题，只需要贪心地让右端点更靠右就可以了。因为数据范围小，所以其实不用优先队列也可以通过。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e2</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[MAXN][MAXN], r[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> high[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN], flag;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">        <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (tx &gt;= <span class="number">1</span> &amp;&amp; tx &lt;= n &amp;&amp; ty &gt;= <span class="number">1</span> &amp;&amp; ty &lt;= m &amp;&amp; !vis[tx][ty] &amp;&amp; high[x][y] &gt; high[tx][ty]) &#123;</span><br><span class="line">            dfs(tx, ty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tx &gt;= <span class="number">1</span> &amp;&amp; tx &lt;= n &amp;&amp; ty &gt;= <span class="number">1</span> &amp;&amp; ty &lt;= m &amp;&amp; high[x][y] &gt; high[tx][ty]) &#123;</span><br><span class="line">            l[x][y] = <span class="built_in">std</span>::min(l[x][y], l[tx][ty]);</span><br><span class="line">            r[x][y] = <span class="built_in">std</span>::max(r[x][y], r[tx][ty]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;high[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(l));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        l[n][i] = r[n][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[<span class="number">1</span>][i]) dfs(<span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[n][i]) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[<span class="number">1</span>][i] &lt;= left) &#123;</span><br><span class="line">                maxr = <span class="built_in">std</span>::max(maxr, r[<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = maxr + <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>【USACO5.3】校园网Network of Schools</title>
    <url>/%E3%80%90USACO5.3%E3%80%91%E6%A0%A1%E5%9B%AD%E7%BD%91Network%20of%20Schools/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 B 在 A 学校的分发列表中， A 也不一定在 B 学校的列表中。</p>
<p>你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。</p>
<a id="more"></a>  

<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包括一个整数 N：网络中的学校数目$(2 &lt;= N &lt;= 100)$。学校用前 N 个正整数标识。</p>
<p>接下来 N 行中每行都表示一个接收学校列表（分发列表）。第 i+1 行包括学校 i 的接收学校的标识符。每个列表用 0 结束。空列表只用一个 0 表示。  </p>
<h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><p>你的程序应该在输出文件中输出两行。  </p>
<p>第一行应该包括一个正整数：子任务 A 的解。  </p>
<p>第二行应该包括子任务 B 的解。  </p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 3 0</span><br><span class="line">4 5 0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>

<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P2746">题目链接</a></h3><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>读完题目之后显然能看出来需要缩点。通过Tarjan算法缩完点之后能得到一张有向无环图。<br>那么问题的答案显然就是求从至少几个点出发能到达所有的点和至少加入几条边来使整个图构成一个强连通分量。<br>第一个问题的答案显然是入度为0的强连通分量的数量。因为只有从这个入度为0的点开始遍历才能遍历到这个点，而入度不为0的点显然是可以以其他点为起点遍历到。所以答案是正确的。<br>对于第二个问题，需要从强连通分量的定义来入手。强连通分量的任意两个点都能相互到达，这也就意味着所有点的出度和入度最起码为1。所以只需要对入度为0的点的数量和出度为0的点的数量取 $max$ 就是答案了。<br>值得一提的是需要特判只有一个点的情况。  </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; edge[MAXN * (MAXN - <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN], chu[MAXN], ru[MAXN], sccTime, sccSize, scc[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inStack[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].s = s;</span><br><span class="line">    edge[cnt].t = t;</span><br><span class="line">    edge[cnt].next = head[s];</span><br><span class="line">    head[s] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++sccTime;</span><br><span class="line">    <span class="built_in">stack</span>.push(u);</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[e].t;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(inStack[v]) &#123;</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u]) &#123;</span><br><span class="line">        sccSize++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            inStack[x] = <span class="literal">false</span>;</span><br><span class="line">            scc[x] = sccSize;</span><br><span class="line">            <span class="keyword">if</span>(u == x) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            <span class="keyword">if</span>(!t) <span class="keyword">break</span>;</span><br><span class="line">            add(i, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e = head[i]; e; e = edge[e].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = edge[e].t;</span><br><span class="line">            <span class="keyword">if</span>(scc[i] != scc[t]) &#123;</span><br><span class="line">                chu[scc[i]]++;</span><br><span class="line">                ru[scc[t]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cntChu = <span class="number">0</span>, cntRu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sccSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chu[i] == <span class="number">0</span>) cntChu++;</span><br><span class="line">        <span class="keyword">if</span>(ru[i] == <span class="number">0</span>) cntRu++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sccSize == <span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cntRu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">std</span>::max(cntChu, cntRu));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算（一）</title>
    <url>/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>计算机中的所有数据都是以二进制的形式存储的，位运算就是直接对这些二进制数据进行操作，因此处理速度非常快。  </p>
<a id="more"></a>

<h2 id="基本的位运算"><a href="#基本的位运算" class="headerlink" title="基本的位运算"></a>基本的位运算</h2><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a><code>&amp;</code></h3><p>按位与运算，当两个位都为<code>1</code>时，结果才为<code>1</code>。<br>例如<code>11 &amp; 13</code>，这两个数转化成二进制之后分别是<code>1011</code>与<code>1101</code>,那么对这两个数进行<code>&amp;</code>操作的结果就是<code>1001</code>,转化为十进制就是<code>9</code>。    </p>
<h3 id=""><a href="#" class="headerlink" title="|"></a><code>|</code></h3><p>按位或运算，两个位都为<code>0</code>时，结果才为<code>0</code>，否则为<code>1</code>。<br>例如<code>10 | 9</code>，转化为二进制后为<code>1010</code>与<code>1001</code>，那么结果就是<code>1011</code>,转化为十进制就是<code>11</code>。  </p>
<h3 id="-1"><a href="#-1" class="headerlink" title="^"></a><code>^</code></h3><p>按位异或运算，两个位相同时为<code>0</code>，不同为<code>1</code>。<br>例如<code>9 ^ 12</code>，转化为二进制之后就是<code>1001</code>与<code>1100</code>，那么结果就是<code>0101</code>，忽略前导<code>0</code>之后的结果就是<code>101</code>，转化为十进制就是<code>5</code>。  </p>
<h3 id="-2"><a href="#-2" class="headerlink" title="~"></a><code>~</code></h3><p>按位取反操作，<code>0</code>变<code>1</code>，<code>1</code>变<code>0</code>。<br>例如<code>~10</code>，转化为二进制就是<code>1010</code>，结果是<code>0101</code>，忽略前导<code>0</code>后为<code>101</code>，转化为十进制就是<code>5</code>。    </p>
<h3 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a><code>&lt;&lt;</code></h3><p>左移运算，将各个二进制位全部左移若干位，超出长度的高位丢弃（长度由变量类型决定），低位补<code>0</code>。<br>例如<code>5 &lt;&lt; 2</code>，把<code>5</code>转化为二进制为<code>101</code>，再把<code>101</code>左移<code>2</code>位，低位补<code>0</code>，结果就是<code>10100</code>，转化为十进制为<code>20</code>。    </p>
<h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a><code>&gt;&gt;</code></h3><p>右移运算，将各个二进制位全部右移若干位，丢弃低位超出的不分。<br>例如<code>10 &gt;&gt; 2</code>，把<code>10</code>转化为二进制为<code>1010</code>，右移<code>2</code>位，丢弃低位的<code>10</code>，结果为<code>10</code>，转化为十进制为<code>2</code>。    </p>
<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>【SCOI2005】互不侵犯King</title>
    <url>/%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AFKing/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。  </p>
<a id="more"></a>  

<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）  </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>所得的方案数  </p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题看完题目描述显然就是一道搜索或者是动态规划，观察数据范围暴搜显然是会超时的。所以我们直接想想动态规划的思路。很多人看到这道题的时候会下意识地想到八皇后问题，实际上这两道题确实有共同之处。我们可以像八皇后那道题一样逐行处理。经过思考我们可以很容易地出状态转移方程。只需把能转移到当前状态的状态累加即可。需要注意的是第三维下标应用了状态也压缩的技巧来存储当前这行国王是如何摆放的。  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;=&quot;</span> &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">10</span>][<span class="number">100</span>][<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop_count</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s &amp; <span class="number">1</span>) ans++;</span><br><span class="line">        s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="keyword">bool</span>(s &amp; (s &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> !ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid2</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> ss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="keyword">bool</span> (s &amp; ss) || (s &amp; (ss &gt;&gt; <span class="number">1</span>)) || (s &amp; (ss &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> !ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t1 = <span class="number">0</span>; t1 &lt; l; t1++)</span><br><span class="line">                <span class="keyword">if</span>(is_valid(t1) &amp;&amp; pop_count(t1) &lt;= j)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t2 = <span class="number">0</span>; t2 &lt; l; t2++)</span><br><span class="line">                        <span class="keyword">if</span>(is_valid(t2) &amp;&amp; is_valid2(t1, t2))&#123;</span><br><span class="line">                            f[i][j][t1] += f[i<span class="number">-1</span>][j-pop_count(t1)][t2];</span><br><span class="line">                            <span class="comment">/*DEBUG(f[i][j][t1])*/</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; l; t++)</span><br><span class="line">        <span class="keyword">if</span>(is_valid(t))</span><br><span class="line">            ans += f[n][k][t] <span class="comment">/*DEBUG(ans)*/</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>【HNOI2009】最小环</title>
    <url>/%E6%9C%80%E5%B0%8F%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.org/problemnew/show/P3199">【HNOI2009】最小环</a></p>
<a id="more"></a>  

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求输出边权平均值最小的环的平均值，再看一眼数据范围，不难联想到我们可以二分答案。剩下的就是如何去check我们的答案。我们让所有边减去一个我们二分平均值，如果存在负环，说明这个答案是成立的。什么算法能用来求负环呢？显而易见是SPFA！值得一提的的地方是常规的队列实现的SPFA用来求负环效率十分低下，因此需要用DFS版的SPFA来求负环。  </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE = <span class="number">10005</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; e[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt = <span class="number">0</span>, n, m;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-9</span>, dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN], flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i != <span class="number">0</span>; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(dis[v] &gt; dis[x] + e[i].w - mid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[v] = dis[x] + e[i].w - mid;</span><br><span class="line">            spfa(v, mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        spfa(i,mid);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lf&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e5</span>, r = <span class="number">1e5</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(r-l &gt; eps) &#123;</span><br><span class="line">        mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8f\n&quot;</span>, mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分答案</tag>
        <tag>分数规划</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
